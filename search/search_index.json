{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyPFC: Phase Field Crystal Simulations","text":"<p>Welcome to pyPFC, a Python package for Phase Field Crystal (PFC) simulations using PyTorch for CPU/GPU acceleration.</p> <p></p>"},{"location":"#overview","title":"Overview","text":"<p>pyPFC is a high-performance simulation framework designed for modeling crystal structures and their evolution using the Phase Field Crystal method. The package leverages PyTorch's tensor operations and automatic differentiation capabilities to provide efficient simulations on both CPU and GPU platforms.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>GPU Acceleration: Full GPU support using PyTorch for large-scale simulations</li> <li>Flexible Architecture: Modular design with inheritance-based class structure</li> <li>Multiple Crystal Structures: Support for BCC, FCC, and custom crystal structures</li> <li>Advanced I/O: VTK, XYZ, and pickle format support for data exchange</li> <li>Visualization Integration: Built-in support for OVITO analysis (optional)</li> <li>Memory Optimization: Efficient memory management for large 3D grids</li> </ul>"},{"location":"#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Grid Management: Flexible 3D Cartesian grid setup with periodic boundary conditions</li> <li>Density Field Evolution: Multiple time integration schemes (1<sup>st</sup> order, 2<sup>nd</sup> order, exponential)</li> <li>Energy Calculations: Free energy evaluation and minimization</li> <li>Structure Analysis: Crystal structure identification and defect analysis</li> <li>Polycrystal Modeling: Multi-grain systems with grain boundary modeling</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import numpy as np\nimport pypfc\n\n# Setup simulation parameters\nnx, ny, nz = 64, 64, 64\ndx, dy, dz = 0.5, 0.5, 0.5\nconfig = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'double'\n}\n\n# Initialize PFC simulation\npfc = pypfc.PyPFC()\npfc.setup_simulation([nx*dx, ny*dy, nz*dz], [nx, ny, nz], config)\n\n# Create single crystal\npfc.do_single_crystal()\n\n# Run simulation steps\nfor step in range(100):\n    pfc.do_step_update()\n\n    if step % 10 == 0:\n        energy = pfc.get_energy()\n        print(f\"Step {step}: Energy = {energy:.6f}\")\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>The pyPFC package follows a strict inheritance hierarchy designed for modularity and extensibility:</p> <pre><code>graph TD\n    A[pypfc_grid] --&gt; B[pypfc_base]\n    B --&gt; C[pypfc_pre]\n    C --&gt; D[pypfc_io]\n    D --&gt; E[pypfc]\n\n    A --&gt; F[Grid setup and domain discretization]\n    B --&gt; G[Device management, FFT operations]\n    C --&gt; H[Density field generation]\n    D --&gt; I[File I/O operations]\n    E --&gt; J[Main simulation class]</code></pre>"},{"location":"#scientific-applications","title":"Scientific Applications","text":"<p>pyPFC is designed for research in:</p> <ul> <li>Materials Science: Crystal growth, phase transitions, microstructure evolution</li> <li>Computational Physics: Nonlinear dynamics, pattern formation, phase field modeling</li> <li>Metallurgy: Grain boundary dynamics, recrystallization, texture evolution</li> <li>Solid State Physics: Defect formation and migration, elastic interactions</li> </ul>"},{"location":"#performance","title":"Performance","text":"<ul> <li>Memory Efficient: Optimized tensor operations with in-place computations</li> <li>Scalable: Supports simulations from small test cases to large-scale production runs</li> <li>Cross-Platform: Compatible with various GPU architectures through PyTorch</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Installation Guide - Setup instructions and dependencies</li> <li>Quick Start Tutorial - Your first PFC simulation</li> <li>Examples - Comprehensive examples and use cases</li> <li>API Reference - Detailed class and method documentation</li> </ol>"},{"location":"#support-and-community","title":"Support and Community","text":"<ul> <li>Documentation: Comprehensive guides and API reference</li> <li>Examples: Jupyter notebooks with detailed explanations</li> <li>GitHub Issues: Bug reports and feature requests</li> <li>Discussions: Community support and questions</li> </ul> <p>pyPFC is developed with a focus on computational efficiency and scientific rigor, making it suitable for both research and educational purposes in phase field crystal modeling.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page provides an overview of all examples included with pyPFC. Each example demonstrates different aspects of the simulation framework.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":""},{"location":"examples/#basic-examples","title":"Basic Examples","text":"Example Description Complexity Quick Start Basic single crystal simulation \u2b50 Density Field Understanding density fields \u2b50"},{"location":"examples/#intermediate-examples","title":"Intermediate Examples","text":"Example Description Complexity Grain Growth Polycrystal grain boundary dynamics \u2b50\u2b50 Grain Boundary Migration Controlled boundary movement \u2b50\u2b50"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":"Example Description Complexity Polycrystal Solidification Phase transformation modeling \u2b50\u2b50\u2b50 Structure Analysis OVITO integration and analysis \u2b50\u2b50\u2b50"},{"location":"examples/#example-details","title":"Example Details","text":""},{"location":"examples/#ex00-density-field","title":"ex00: Density Field","text":"<p>File: <code>examples/ex00_density_field.py</code></p> <p>This example introduces the fundamental concept of density fields in PFC simulations.</p> <pre><code>import pypfc\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Basic density field visualization\npfc = pypfc.PyPFC()\ndomain_size = [20.0, 20.0, 4.0]\nndiv = [40, 40, 8]\n\npfc.setup_simulation(domain_size, ndiv, {'device_type': 'CPU'})\npfc.do_single_crystal()\n\n# Get and visualize density field\ndensity = pfc.get_density_field()\nplt.figure(figsize=(12, 4))\n\n# Show different slices\nfor i, z in enumerate([0, ndiv[2]//2, ndiv[2]-1]):\n    plt.subplot(1, 3, i+1)\n    plt.imshow(density[:, :, z], cmap='viridis')\n    plt.title(f'z-slice {z}')\n    plt.colorbar()\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Learning Goals: - Understanding density field representation - Basic visualization techniques - Grid indexing and slicing</p>"},{"location":"examples/#ex01-grain-growth","title":"ex01: Grain Growth","text":"<p>File: <code>examples/ex01_grain_growth.py</code></p> <p>Demonstrates polycrystal systems and grain boundary dynamics.</p> <pre><code>import pypfc\nimport numpy as np\n\n# Setup polycrystal simulation\npfc = pypfc.PyPFC()\ndomain_size = [64.0, 64.0, 16.0]\nndiv = [128, 128, 32]\n\nconfig = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'single',\n    'grain_seeds': [4, 4],  # 4x4 grain structure\n    'update_scheme': 'exponential',\n    'update_scheme_params': [1.0, 0.01]\n}\n\npfc.setup_simulation(domain_size, ndiv, config)\npfc.do_polycrystal()\n\n# Monitor grain evolution\ngrain_sizes = []\nsimulation_steps = 500\n\nfor step in range(simulation_steps):\n    pfc.do_step_update()\n\n    if step % 50 == 0:\n        # Analyze grain structure\n        positions = pfc.interpolate_density_maxima()\n        energy = pfc.get_energy()\n\n        print(f\"Step {step}: Energy = {energy:.6f}, Atoms = {len(positions)}\")\n\n        # Save snapshots\n        if step % 100 == 0:\n            pfc.write_vtk_points(f'grain_growth_step_{step:04d}.vtu')\n\nprint(\"Grain growth simulation complete\")\n</code></pre> <p>Key Features: - Polycrystal initialization - Long-term evolution tracking - Energy minimization monitoring - Grain boundary migration</p> <p>Output Files: - <code>grain_growth_step_*.vtu</code> - Atomic positions at different times - Analysis data for grain size evolution</p>"},{"location":"examples/#ex02-grain-boundary-migration","title":"ex02: Grain Boundary Migration","text":"<p>File: <code>examples/ex02_grain_boundary_migration.py</code></p> <p>Focuses on controlled grain boundary dynamics with external driving forces.</p> <pre><code>import pypfc\nimport numpy as np\n\n# Specialized grain boundary setup\npfc = pypfc.PyPFC()\ndomain_size = [32.0, 64.0, 8.0]\nndiv = [64, 128, 16]\n\n# Configuration for boundary migration study\nconfig = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'double',\n    'boundary_type': 'tilt',\n    'misorientation_angle': 15.0,  # degrees\n    'driving_force': 0.001,\n    'update_scheme': '2nd_order',\n    'update_scheme_params': [0.5, 0.001]\n}\n\npfc.setup_simulation(domain_size, ndiv, config)\n\n# Create bicrystal with controlled boundary\npfc.do_bicrystal_tilt_boundary()\n\n# Track boundary position\nboundary_positions = []\ntimes = []\n\nfor step in range(1000):\n    pfc.do_step_update()\n\n    if step % 10 == 0:\n        # Measure boundary position\n        density = pfc.get_density_field()\n        boundary_pos = pfc.analyze_grain_boundary(density)\n\n        boundary_positions.append(boundary_pos)\n        times.append(step * config['update_scheme_params'][0])\n\n        if step % 100 == 0:\n            print(f\"Step {step}: Boundary at y = {boundary_pos:.2f}\")\n\n# Calculate migration velocity\nvelocity = np.gradient(boundary_positions, times)\nprint(f\"Average migration velocity: {np.mean(velocity):.6f} units/time\")\n</code></pre> <p>Analysis Features: - Boundary position tracking - Migration velocity calculation - Crystallographic orientation analysis - Driving force effects</p>"},{"location":"examples/#ex03-polycrystal-solidification","title":"ex03: Polycrystal Solidification","text":"<p>File: <code>examples/ex03_polycrystal_solidification.py</code></p> <p>Advanced example showing liquid-solid phase transformation.</p> <pre><code>import pypfc\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Large-scale solidification simulation\npfc = pypfc.PyPFC()\ndomain_size = [100.0, 100.0, 20.0]\nndiv = [200, 200, 40]\n\nconfig = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'single',\n    'initial_phase': 'liquid',\n    'nucleation_sites': 25,\n    'temperature_gradient': True,\n    'cooling_rate': 0.001,\n    'update_scheme': 'exponential'\n}\n\npfc.setup_simulation(domain_size, ndiv, config)\n\n# Initialize with liquid phase\npfc.do_liquid_phase()\n\n# Add nucleation sites\nnucleation_positions = pfc.add_random_nuclei(config['nucleation_sites'])\n\n# Solidification process\nsolid_fraction = []\ntemperatures = []\n\nfor step in range(2000):\n    pfc.do_step_update()\n\n    # Apply cooling\n    if step % 10 == 0:\n        current_temp = pfc.reduce_temperature(config['cooling_rate'])\n        temperatures.append(current_temp)\n\n        # Measure solidification\n        density = pfc.get_density_field()\n        solid_frac = pfc.calculate_solid_fraction(density)\n        solid_fraction.append(solid_frac)\n\n        print(f\"Step {step}: T = {current_temp:.4f}, Solid = {solid_frac:.3f}\")\n\n        if step % 200 == 0:\n            pfc.write_vtk_points(f'solidification_{step:04d}.vtu')\n\n# Plot solidification curve\nplt.figure(figsize=(10, 6))\nplt.plot(temperatures, solid_fraction, 'b-', linewidth=2)\nplt.xlabel('Temperature')\nplt.ylabel('Solid Fraction')\nplt.title('Solidification Curve')\nplt.grid(True)\nplt.show()\n</code></pre> <p>Advanced Features: - Phase transformation modeling - Temperature control - Nucleation and growth - Solidification kinetics analysis</p>"},{"location":"examples/#ex04-quick-start","title":"ex04: Quick Start","text":"<p>File: <code>examples/ex04_quick_start.py</code></p> <p>The simplest example to get started with pyPFC.</p> <pre><code>import pypfc\n\n# Minimal working example\npfc = pypfc.PyPFC()\npfc.setup_simulation([16.0, 16.0, 4.0], [32, 32, 8])\npfc.do_single_crystal()\n\n# Run 50 steps\nfor step in range(50):\n    pfc.do_step_update()\n\n    if step % 10 == 0:\n        energy = pfc.get_energy()\n        print(f\"Step {step}: Energy = {energy:.6f}\")\n\n# Save results\npfc.write_extended_xyz('quickstart_result.xyz')\nprint(\"Quick start complete!\")\n</code></pre> <p>Perfect For: - First-time users - Installation verification - Basic functionality testing</p>"},{"location":"examples/#ex05-structure-analysis","title":"ex05: Structure Analysis","text":"<p>File: <code>examples/ex05_structure_analysis.py</code></p> <p>Integration with OVITO for advanced structural analysis.</p> <p>Requirements</p> <p>This example requires OVITO to be installed: <pre><code>pip install ovito\n</code></pre></p> <pre><code>import pypfc\nfrom pypfc_ovito import OvitoAnalyzer\nimport numpy as np\n\n# Create test structure\npfc = pypfc.PyPFC()\ndomain_size = [40.0, 40.0, 10.0]\nndiv = [80, 80, 20]\n\npfc.setup_simulation(domain_size, ndiv, {'device_type': 'GPU'})\npfc.do_single_crystal()\n\n# Run simulation to develop defects\nfor step in range(200):\n    pfc.do_step_update()\n\n# Extract atomic positions\npositions = pfc.interpolate_density_maxima()\npfc.write_extended_xyz('structure_for_analysis.xyz')\n\n# Initialize OVITO analyzer\nanalyzer = OvitoAnalyzer('structure_for_analysis.xyz')\n\n# Perform various analyses\nresults = analyzer.analyze_structure({\n    'common_neighbor_analysis': True,\n    'polyhedral_template_matching': True,\n    'dislocation_analysis': True,\n    'elastic_strain': True\n})\n\nprint(\"Structure Analysis Results:\")\nprint(f\"Total atoms: {results['n_atoms']}\")\nprint(f\"Crystal structure: {results['crystal_structure']}\")\nprint(f\"Defect atoms: {results['defect_count']}\")\n\nif 'dislocations' in results:\n    print(f\"Dislocation lines: {len(results['dislocations'])}\")\n    for i, disl in enumerate(results['dislocations']):\n        print(f\"  Dislocation {i}: {disl['burgers_vector']}\")\n\n# Generate visualization\nanalyzer.create_visualization({\n    'color_by': 'structure_type',\n    'show_dislocations': True,\n    'export_image': 'structure_analysis.png'\n})\n\nprint(\"Analysis complete. Check 'structure_analysis.png' for visualization.\")\n</code></pre> <p>Analysis Capabilities: - Crystal structure identification - Defect detection and classification - Dislocation analysis - Elastic strain calculation - Automated visualization</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#command-line","title":"Command Line","text":"<pre><code># Navigate to examples directory\ncd examples/\n\n# Run specific example\npython ex04_quick_start.py\n\n# Run with specific GPU\nCUDA_VISIBLE_DEVICES=0 python ex01_grain_growth.py\n</code></pre>"},{"location":"examples/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<p>Interactive versions of all examples are available as Jupyter notebooks:</p> <pre><code># Start Jupyter\njupyter notebook\n\n# Open any .ipynb file in the examples directory\n</code></pre>"},{"location":"examples/#batch-processing","title":"Batch Processing","text":"<p>For parameter studies:</p> <pre><code># Run multiple configurations\nfor size in 32 64 128; do\n    python ex01_grain_growth.py --grid_size $size --output_dir results_$size\ndone\n</code></pre>"},{"location":"examples/#output-files","title":"Output Files","text":"<p>Examples generate various output files:</p> Extension Description Viewer <code>.vtu</code> VTK unstructured grid ParaView, VisIt <code>.xyz</code> Extended XYZ format OVITO, VMD <code>.pkl</code> Python pickle Custom analysis <code>.png/.jpg</code> Images Any image viewer <code>.txt</code> Data files Text editor, plotting"},{"location":"examples/#performance-notes","title":"Performance Notes","text":""},{"location":"examples/#gpu-memory-requirements","title":"GPU Memory Requirements","text":"Grid Size Memory (Single) Memory (Double) 64\u00b3 ~1 GB ~2 GB 128\u00b3 ~8 GB ~16 GB 256\u00b3 ~64 GB ~128 GB"},{"location":"examples/#recommended-configurations","title":"Recommended Configurations","text":"<p>For Testing (fast execution): <pre><code>config = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'single',\n    'update_scheme': 'exponential',\n    'update_scheme_params': [2.0, 0.1]\n}\n</code></pre></p> <p>For Production (high accuracy): <pre><code>config = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'double',\n    'update_scheme': '2nd_order',\n    'update_scheme_params': [0.5, 0.001]\n}\n</code></pre></p>"},{"location":"examples/#customization","title":"Customization","text":"<p>All examples can be customized by modifying parameters:</p> <pre><code># Modify any example\ndomain_size = [custom_x, custom_y, custom_z]\nndiv = [custom_nx, custom_ny, custom_nz]\nconfig['your_parameter'] = your_value\n</code></pre> <p>For more advanced customization, see the API documentation.</p> <p>Next Steps: Try running the examples and explore the API reference to understand the underlying methods.</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide will help you install pyPFC and its dependencies on your system.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing pyPFC, ensure you have the following prerequisites:</p>"},{"location":"installation/#python-requirements","title":"Python Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>pip package manager</li> </ul>"},{"location":"installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Minimum: 4 GB RAM, 2 GB disk space</li> <li>Recommended: 16 GB RAM, GPU with CUDA support</li> <li>Operating Systems: Linux, macOS, Windows</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-development-installation-recommended","title":"Method 1: Development Installation (Recommended)","text":"<p>For development or if you want to modify the code:</p> <pre><code># Clone the repository\ngit clone https://github.com/HHallb/pyPFC.git\ncd pyPFC\n\n# Install in development mode\npip install -e .\n</code></pre>"},{"location":"installation/#method-2-direct-installation-from-github","title":"Method 2: Direct Installation from GitHub","text":"<pre><code>pip install git+https://github.com/HHallb/pyPFC.git\n</code></pre>"},{"location":"installation/#method-3-local-installation","title":"Method 3: Local Installation","text":"<p>If you have downloaded the source code:</p> <pre><code># Navigate to the pyPFC directory\ncd path/to/pyPFC\n\n# Install the package\npip install .\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>pyPFC automatically installs the following required dependencies:</p>"},{"location":"installation/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>PyTorch (\u22651.9.0): GPU/CPU tensor operations and FFT</li> <li>NumPy (\u22651.20.0): Numerical computations</li> <li>SciPy (\u22651.7.0): Scientific computing utilities</li> </ul>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For enhanced functionality, you may want to install:</p> <pre><code># For visualization and analysis\npip install matplotlib vtk\n\n# For OVITO integration (optional)\npip install ovito\n\n# For Jupyter notebook examples\npip install jupyter ipywidgets\n</code></pre>"},{"location":"installation/#gpu-support","title":"GPU Support","text":""},{"location":"installation/#cuda-installation","title":"CUDA Installation","text":"<p>For GPU acceleration, install PyTorch with CUDA support:</p> <pre><code># For CUDA 11.8 (check your CUDA version)\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118\n\n# For CUDA 12.1\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121\n\n# For CPU-only (if no GPU available)\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu\n</code></pre>"},{"location":"installation/#verify-gpu-support","title":"Verify GPU Support","text":"<pre><code>import torch\nprint(f\"CUDA available: {torch.cuda.is_available()}\")\nprint(f\"CUDA devices: {torch.cuda.device_count()}\")\nif torch.cuda.is_available():\n    print(f\"Current device: {torch.cuda.get_device_name()}\")\n</code></pre>"},{"location":"installation/#virtual-environment-recommended","title":"Virtual Environment (Recommended)","text":"<p>Use a virtual environment to avoid dependency conflicts:</p> <pre><code># Create virtual environment\npython -m venv pypfc_env\n\n# Activate (Linux/macOS)\nsource pypfc_env/bin/activate\n\n# Activate (Windows)\npypfc_env\\Scripts\\activate\n\n# Install pyPFC\npip install -e .\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify your installation:</p> <pre><code>import pypfc\nimport torch\nimport numpy as np\n\n# Test basic functionality\npfc = pypfc.PyPFC()\nprint(\"pyPFC successfully imported!\")\n\n# Check versions\nprint(f\"PyTorch version: {torch.__version__}\")\nprint(f\"NumPy version: {np.__version__}\")\nprint(f\"CUDA available: {torch.cuda.is_available()}\")\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#importerror-no-module-named-pypfc","title":"ImportError: No module named 'pypfc'","text":"<p>Solution: Make sure you're in the correct environment and pyPFC is installed:</p> <pre><code>pip list | grep pypfc\n</code></pre>"},{"location":"installation/#cuda-out-of-memory","title":"CUDA Out of Memory","text":"<p>Solution: Reduce simulation size or use CPU:</p> <pre><code>config = {'device_type': 'CPU'}\npfc.setup_simulation(domain_size, ndiv, config)\n</code></pre>"},{"location":"installation/#fft-errors","title":"FFT Errors","text":"<p>Solution: Ensure grid dimensions are even numbers:</p> <pre><code># Good: even dimensions\nndiv = [64, 64, 32]\n\n# Bad: odd dimensions\nndiv = [63, 65, 31]\n</code></pre>"},{"location":"installation/#performance-issues","title":"Performance Issues","text":""},{"location":"installation/#slow-simulations","title":"Slow Simulations","text":"<ol> <li>Enable GPU: Verify CUDA installation and GPU detection</li> <li>Memory Layout: Ensure tensors are contiguous</li> <li>Grid Size: Start with smaller grids for testing</li> </ol>"},{"location":"installation/#memory-issues","title":"Memory Issues","text":"<ol> <li>Reduce Grid Size: Use smaller <code>ndiv</code> values</li> <li>Use Single Precision: Set <code>dtype_gpu: 'single'</code></li> <li>Clear Cache: Call <code>torch.cuda.empty_cache()</code></li> </ol>"},{"location":"installation/#development-setup","title":"Development Setup","text":"<p>For contributing to pyPFC:</p> <pre><code># Clone with development tools\ngit clone https://github.com/HHallb/pyPFC.git\ncd pyPFC\n\n# Install development dependencies\npip install -e \".[dev]\"\n\n# Run tests\npython -m pytest tests/\n\n# Check code style\nflake8 src/\n</code></pre>"},{"location":"installation/#docker-installation","title":"Docker Installation","text":"<p>For containerized deployment:</p> <pre><code>FROM pytorch/pytorch:latest\n\nWORKDIR /app\nCOPY . /app\n\nRUN pip install -e .\n\nCMD [\"python\", \"-c\", \"import pypfc; print('pyPFC ready!')\"]\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Quick Start Guide - Run your first simulation</li> <li>Examples - Explore example notebooks</li> <li>API Documentation - Learn the API</li> </ol> <p>Need Help? </p> <ul> <li>Check the troubleshooting section</li> <li>Review GitHub Issues</li> <li>Join the community discussions</li> </ul>"},{"location":"quick_start/","title":"Quick Start Guide","text":"<p>This guide will get you running your first pyPFC simulation in minutes.</p>"},{"location":"quick_start/#your-first-simulation","title":"Your First Simulation","text":"<p>Let's create a simple single crystal simulation:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport pypfc\n\n# 1. Initialize the PFC simulation\npfc = pypfc.PyPFC()\n\n# 2. Define simulation parameters\ndomain_size = [32.0, 32.0, 8.0]  # Domain size in lattice units\nndiv = [64, 64, 16]               # Grid divisions (must be even)\n\n# Configuration\nconfig = {\n    'device_type': 'GPU',         # Use 'CPU' if no GPU available\n    'dtype_gpu': 'double',        # Precision: 'single' or 'double'\n    'update_scheme': 'exponential',\n    'update_scheme_params': [1.0, 0.01]  # [dt, tolerance]\n}\n\n# 3. Setup the simulation\npfc.setup_simulation(domain_size, ndiv, config)\n\n# 4. Create initial crystal structure\npfc.do_single_crystal()\n\nprint(\"Initial setup complete!\")\nprint(f\"Domain: {domain_size}\")\nprint(f\"Grid: {ndiv}\")\nprint(f\"Device: {pfc.get_device_type()}\")\n</code></pre>"},{"location":"quick_start/#running-the-simulation","title":"Running the Simulation","text":"<pre><code># Run simulation for 100 steps\nenergies = []\nsteps = []\n\nfor step in range(100):\n    # Update the system\n    pfc.do_step_update()\n\n    # Monitor energy every 10 steps\n    if step % 10 == 0:\n        energy = pfc.get_energy()\n        energies.append(energy)\n        steps.append(step)\n        print(f\"Step {step:3d}: Energy = {energy:.6f}\")\n\n# Plot energy evolution\nplt.figure(figsize=(8, 5))\nplt.plot(steps, energies, 'b-o', linewidth=2, markersize=4)\nplt.xlabel('Simulation Step')\nplt.ylabel('Free Energy')\nplt.title('Energy Evolution')\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"quick_start/#analyzing-results","title":"Analyzing Results","text":""},{"location":"quick_start/#extract-atomic-positions","title":"Extract Atomic Positions","text":"<pre><code># Get density field and find atom positions\ndensity = pfc.get_density_field()\npositions = pfc.interpolate_density_maxima()\n\nprint(f\"Found {len(positions)} atoms\")\nprint(f\"Density range: {density.min():.3f} to {density.max():.3f}\")\n\n# Visualize atomic positions (2D slice)\nplt.figure(figsize=(10, 8))\nz_slice = density.shape[2] // 2  # Middle slice\nplt.imshow(density[:, :, z_slice], cmap='viridis', origin='lower')\nplt.colorbar(label='Density')\nplt.title(f'Density Field (z-slice {z_slice})')\n\n# Overlay atom positions in this slice\nslice_atoms = positions[np.abs(positions[:, 2] - z_slice) &lt; 1]\nif len(slice_atoms) &gt; 0:\n    plt.scatter(slice_atoms[:, 1], slice_atoms[:, 0], \n               c='red', s=20, alpha=0.7, label='Atoms')\n    plt.legend()\n\nplt.xlabel('Y Grid Points')\nplt.ylabel('X Grid Points')\nplt.show()\n</code></pre>"},{"location":"quick_start/#save-results","title":"Save Results","text":"<pre><code># Save density field and atomic positions\npfc.write_vtk_points('single_crystal_atoms.vtu')\npfc.write_extended_xyz('single_crystal_atoms.xyz')\n\nprint(\"Results saved:\")\nprint(\"- single_crystal_atoms.vtu (for ParaView)\")\nprint(\"- single_crystal_atoms.xyz (for OVITO/VMD)\")\n</code></pre>"},{"location":"quick_start/#advanced-example-polycrystal","title":"Advanced Example: Polycrystal","text":"<pre><code># Create a polycrystal system\npfc_poly = pypfc.PyPFC()\n\n# Setup larger domain for polycrystal\ndomain_size = [64.0, 64.0, 16.0]\nndiv = [128, 128, 32]\n\nconfig_poly = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'single',  # Use single precision for larger systems\n    'polycrystal': True,\n    'grain_seeds': [3, 3],  # 3x3 grains\n}\n\npfc_poly.setup_simulation(domain_size, ndiv, config_poly)\n\n# Generate polycrystal structure\npfc_poly.do_polycrystal()\n\n# Run shorter simulation (polycrystals take more time)\nfor step in range(50):\n    pfc_poly.do_step_update()\n\n    if step % 10 == 0:\n        energy = pfc_poly.get_energy()\n        print(f\"Polycrystal Step {step:2d}: Energy = {energy:.6f}\")\n\n# Analyze grain structure\npositions = pfc_poly.interpolate_density_maxima()\npfc_poly.write_vtk_points('polycrystal_atoms.vtu')\n\nprint(f\"Polycrystal complete with {len(positions)} atoms\")\n</code></pre>"},{"location":"quick_start/#configuration-options","title":"Configuration Options","text":""},{"location":"quick_start/#essential-parameters","title":"Essential Parameters","text":"Parameter Description Default Options <code>device_type</code> Computation device <code>'GPU'</code> <code>'GPU'</code>, <code>'CPU'</code> <code>dtype_gpu</code> Precision <code>'double'</code> <code>'single'</code>, <code>'double'</code> <code>update_scheme</code> Time integration <code>'exponential'</code> <code>'1st_order'</code>, <code>'2nd_order'</code>, <code>'exponential'</code>"},{"location":"quick_start/#performance-tips","title":"Performance Tips","text":"<pre><code># For large simulations\nconfig_large = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'single',      # Faster, less memory\n    'update_scheme': 'exponential',\n    'update_scheme_params': [1.0, 0.1],  # Larger time step\n    'density_threshold': 0.5,   # Lower threshold for atom detection\n}\n\n# For high accuracy\nconfig_precise = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'double',      # Higher precision\n    'update_scheme': '2nd_order',\n    'update_scheme_params': [0.5, 0.001],  # Smaller time step\n    'density_interp_order': 3,  # Higher interpolation order\n}\n</code></pre>"},{"location":"quick_start/#common-patterns","title":"Common Patterns","text":""},{"location":"quick_start/#monitoring-convergence","title":"Monitoring Convergence","text":"<pre><code>def check_convergence(pfc, tolerance=1e-6, window=10):\n    \"\"\"Check if simulation has converged based on energy stability\"\"\"\n    energies = []\n\n    for step in range(window):\n        pfc.do_step_update()\n        energies.append(pfc.get_energy())\n\n    energy_std = np.std(energies)\n    return energy_std &lt; tolerance, energy_std\n\n# Usage\nconverged, stability = check_convergence(pfc)\nprint(f\"Converged: {converged}, Stability: {stability:.2e}\")\n</code></pre>"},{"location":"quick_start/#memory-management","title":"Memory Management","text":"<pre><code>import torch\n\ndef run_with_memory_check(pfc, max_steps=1000):\n    \"\"\"Run simulation with memory monitoring\"\"\"\n\n    for step in range(max_steps):\n        pfc.do_step_update()\n\n        # Check memory every 100 steps\n        if step % 100 == 0 and torch.cuda.is_available():\n            memory_used = torch.cuda.memory_allocated() / 1e9  # GB\n            print(f\"Step {step}: Memory used = {memory_used:.2f} GB\")\n\n            # Clear cache if memory is high\n            if memory_used &gt; 8.0:  # 8 GB threshold\n                torch.cuda.empty_cache()\n</code></pre>"},{"location":"quick_start/#next-steps","title":"Next Steps","text":"<p>Now that you've run your first simulation:</p> <ol> <li>Explore Examples: Check out the examples gallery</li> <li>Learn the API: Read the API documentation</li> <li>Advanced Usage: Explore more complex simulation setups</li> </ol>"},{"location":"quick_start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quick_start/#common-issues","title":"Common Issues","text":"<p>Simulation \"melts\" (atoms disappear): - Check that <code>domain_size</code> matches crystal periodicity - Reduce time step in <code>update_scheme_params</code></p> <p>GPU out of memory: - Use <code>'dtype_gpu': 'single'</code> - Reduce <code>ndiv</code> values - Call <code>torch.cuda.empty_cache()</code></p> <p>Slow performance: - Verify GPU is being used: <code>pfc.get_device_type()</code> - Check PyTorch CUDA installation - Ensure <code>ndiv</code> values are even numbers</p> <p>Ready for more? Explore the comprehensive examples to see pyPFC's full capabilities!</p>"},{"location":"api/core/","title":"Core Classes","text":"<p>This section documents the core classes of the pyPFC framework.</p>"},{"location":"api/core/#pypfc-main-class","title":"PyPFC Main Class","text":"<p>The main interface class for Phase Field Crystal simulations.</p>"},{"location":"api/core/#class-overview","title":"Class Overview","text":"<pre><code>class PyPFC:\n    \"\"\"\n    Main class for Phase Field Crystal simulations using PyTorch.\n\n    This class provides a high-level interface for setting up and running\n    PFC simulations on both CPU and GPU devices.\n    \"\"\"\n\n    def setup_simulation(self, domain_size, ndiv, config=None):\n        \"\"\"Setup simulation domain and parameters.\"\"\"\n        pass\n\n    def do_single_crystal(self):\n        \"\"\"Initialize single crystal structure.\"\"\"\n        pass\n\n    def do_step_update(self):\n        \"\"\"Perform one time integration step.\"\"\"\n        pass\n\n    def get_energy(self):\n        \"\"\"Calculate and return system free energy.\"\"\"\n        pass\n</code></pre>"},{"location":"api/core/#architecture-overview","title":"Architecture Overview","text":"<p>The pyPFC framework follows a strict inheritance hierarchy designed for modularity and extensibility:</p> <pre><code>graph TD\n    A[pypfc_grid] --&gt; B[pypfc_base]\n    B --&gt; C[pypfc_pre]\n    C --&gt; D[pypfc_io]\n    D --&gt; E[PyPFC]\n\n    A -.-&gt; F[Grid Management&lt;br/&gt;\u2022 Domain discretization&lt;br/&gt;\u2022 Boundary conditions&lt;br/&gt;\u2022 Coordinate systems]\n    B -.-&gt; G[Core Operations&lt;br/&gt;\u2022 Device management&lt;br/&gt;\u2022 FFT operations&lt;br/&gt;\u2022 Mathematical functions]\n    C -.-&gt; H[Crystal Setup&lt;br/&gt;\u2022 Density field generation&lt;br/&gt;\u2022 Structure initialization&lt;br/&gt;\u2022 Phase field creation]\n    D -.-&gt; I[Input/Output&lt;br/&gt;\u2022 VTK export&lt;br/&gt;\u2022 XYZ format&lt;br/&gt;\u2022 Pickle serialization]\n    E -.-&gt; J[Main Interface&lt;br/&gt;\u2022 Simulation control&lt;br/&gt;\u2022 Time integration&lt;br/&gt;\u2022 Energy evaluation]</code></pre>"},{"location":"api/core/#class-descriptions","title":"Class Descriptions","text":""},{"location":"api/core/#grid-management-pypfc_grid","title":"Grid Management (pypfc_grid)","text":"<p>Base class handling spatial discretization and domain setup.</p> <p>Key Responsibilities: - 3D Cartesian grid initialization - Periodic boundary condition setup - Coordinate system management - Grid validation (even number requirements)</p> <p>Important Methods: - <code>set_ndiv()</code> - Set grid divisions - <code>set_domain_size()</code> - Define physical domain - <code>get_grid_spacing()</code> - Calculate grid resolution</p>"},{"location":"api/core/#base-operations-pypfc_base","title":"Base Operations (pypfc_base)","text":"<p>Core mathematical and computational operations.</p> <p>Key Responsibilities: - Device management (CPU/GPU) - FFT operations and wave vector calculations - Tensor memory management - Precision control (single/double)</p> <p>Important Methods: - <code>set_device_type()</code> - Configure computation device - <code>setup_fft()</code> - Initialize Fourier transforms - <code>get_k2_field()</code> - Wave vector calculations</p>"},{"location":"api/core/#crystal-preprocessing-pypfc_pre","title":"Crystal Preprocessing (pypfc_pre)","text":"<p>Crystal structure generation and initialization.</p> <p>Key Responsibilities: - Density field creation - Crystal structure setup (BCC, FCC) - Polycrystal initialization - Phase field preparation</p> <p>Important Methods: - <code>setup_crystal_structure()</code> - Define crystal type - <code>generate_density_field()</code> - Create initial density - <code>apply_crystal_orientation()</code> - Set grain orientations</p>"},{"location":"api/core/#inputoutput-pypfc_io","title":"Input/Output (pypfc_io)","text":"<p>Data persistence and visualization support.</p> <p>Key Responsibilities: - File format support (VTK, XYZ, pickle) - Atomic position export - Density field visualization - Simulation state serialization</p> <p>Important Methods: - <code>write_vtk_points()</code> - Export to ParaView format - <code>write_extended_xyz()</code> - Export for OVITO/VMD - <code>save_simulation_state()</code> - Checkpoint creation</p>"},{"location":"api/core/#main-interface-pypfc","title":"Main Interface (PyPFC)","text":"<p>High-level simulation control and user interface.</p> <p>Key Responsibilities: - Simulation setup and configuration - Time integration control - Energy evaluation and monitoring - Results analysis and extraction</p> <p>Main Methods: - <code>setup_simulation()</code> - Initialize complete simulation - <code>do_step_update()</code> - Advance time integration - <code>get_energy()</code> - Calculate free energy - <code>interpolate_density_maxima()</code> - Extract atomic positions</p>"},{"location":"api/core/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/core/#basic-initialization","title":"Basic Initialization","text":"<pre><code>import pypfc\n\n# Create simulation instance\npfc = pypfc.PyPFC()\n\n# Setup simulation domain\ndomain_size = [32.0, 32.0, 8.0]  # Physical size\nndiv = [64, 64, 16]               # Grid divisions\n\n# Configuration\nconfig = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'double',\n    'update_scheme': 'exponential'\n}\n\n# Initialize simulation\npfc.setup_simulation(domain_size, ndiv, config)\n</code></pre>"},{"location":"api/core/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code># Comprehensive configuration\nconfig = {\n    # Device settings\n    'device_type': 'GPU',           # 'CPU' or 'GPU'\n    'device_number': 0,             # GPU device index\n    'dtype_gpu': 'double',          # 'single' or 'double'\n\n    # Simulation parameters\n    'update_scheme': 'exponential', # Time integration method\n    'update_scheme_params': [1.0, 0.01],  # [dt, tolerance]\n    'max_iterations': 1000,         # Maximum steps per update\n\n    # Crystal structure\n    'crystal_structure': 'BCC',     # 'BCC', 'FCC', 'HCP'\n    'lattice_parameter': 1.0,       # Crystal lattice spacing\n\n    # Density field\n    'density_amplitude': 1.0,       # Field amplitude\n    'density_threshold': 0.5,       # Atom detection threshold\n    'density_interp_order': 2,      # Interpolation accuracy\n\n    # Polycrystal settings\n    'grain_seeds': [3, 3],          # Number of grains [nx, ny]\n    'grain_orientations': 'random', # Orientation distribution\n    'grain_boundary_width': 2.0,    # GB thickness\n\n    # Output control\n    'output_frequency': 10,         # Steps between outputs\n    'output_format': 'vtk',         # Output file format\n    'output_precision': 'single'    # Output data precision\n}\n</code></pre>"},{"location":"api/core/#error-handling","title":"Error Handling","text":""},{"location":"api/core/#common-exceptions","title":"Common Exceptions","text":"<pre><code>try:\n    pfc.setup_simulation(domain_size, ndiv, config)\nexcept ValueError as e:\n    print(f\"Configuration error: {e}\")\nexcept RuntimeError as e:\n    print(f\"GPU/memory error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"api/core/#validation-methods","title":"Validation Methods","text":"<pre><code># Check configuration validity\nis_valid = pfc.validate_configuration(config)\nif not is_valid:\n    print(\"Configuration validation failed\")\n\n# Check GPU availability\nif not pfc.check_gpu_available():\n    config['device_type'] = 'CPU'\n    print(\"GPU not available, using CPU\")\n\n# Validate grid dimensions\nif not pfc.validate_grid_dimensions(ndiv):\n    print(\"Grid dimensions must be even numbers\")\n</code></pre>"},{"location":"api/core/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/core/#memory-usage","title":"Memory Usage","text":"Grid Size Single Precision Double Precision 64\u00b3 ~1 GB ~2 GB 128\u00b3 ~8 GB ~16 GB 256\u00b3 ~64 GB ~128 GB"},{"location":"api/core/#optimization-tips","title":"Optimization Tips","text":"<pre><code># For maximum performance\nconfig_fast = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'single',          # Faster computation\n    'update_scheme': 'exponential', # Efficient time stepping\n    'fft_backend': 'cufft',         # GPU-optimized FFT\n    'memory_pool': True,            # Reuse GPU memory\n}\n\n# For maximum accuracy\nconfig_precise = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'double',          # Higher precision\n    'update_scheme': '2nd_order',   # More accurate integration\n    'convergence_tolerance': 1e-8,  # Stricter convergence\n    'density_interp_order': 3,      # Better interpolation\n}\n</code></pre>"},{"location":"api/core/#thread-safety","title":"Thread Safety","text":"<p>Thread Safety</p> <p>PyPFC instances are not thread-safe. For parallel simulations:</p> <ul> <li>Use separate PyPFC instances per thread</li> <li>Ensure different GPU devices per instance</li> <li>Avoid shared state between instances</li> </ul> <pre><code># Correct: separate instances\ndef run_simulation(config, thread_id):\n    pfc = pypfc.PyPFC()  # New instance per thread\n    config['device_number'] = thread_id % torch.cuda.device_count()\n    pfc.setup_simulation(domain_size, ndiv, config)\n    # ... run simulation\n</code></pre>"},{"location":"api/core/#next-steps","title":"Next Steps","text":"<ul> <li>Grid Management API - Detailed grid operations</li> <li>I/O Operations API - File handling and export</li> <li>Usage Examples - Practical applications</li> </ul>"}]}