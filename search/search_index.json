{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#a-python-package-for-gpu-accelerated-3d-phase-field-crystal-simulations","title":"A Python package for GPU-accelerated 3D Phase Field Crystal simulations","text":""},{"location":"#overview","title":"Overview","text":"<p>pyPFC is a high-performance simulation framework designed for modeling crystal structures and their evolution using the Phase Field Crystal (PFC) method. The code uses PyTorch to allow execution on both CPUs and GPUs, with particularly efficiency gained on GPU platforms. pyPFC is developed with a combined focus on computational efficiency, flexibility and accessibility, making it suitable for both research and educational purposes. Areas of application include:</p> <ul> <li>Materials Science: Crystal growth and microstructure evolution</li> <li>Computational Physics: Pattern formation, defect evolution and elastic interactions</li> <li>Metallurgy: Grain boundary and dislocation mechanics</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>GPU Acceleration: Full GPU support using PyTorch for large-scale simulations</li> <li>Adjustable Floating Point Precision: Permits optimized use of GPU memory resources and execution efficiency</li> <li>Flexible I/O: VTK, Extended XYZ and pickle format support for data exchange</li> <li>Advanced Data Processing: Built-in functionalities as well as interfaces to OVITO libraries (optional)</li> <li>Memory Optimization: Efficient memory management for large 3D grids</li> <li>Density Field Evolution: Different time integration schemes are available</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Installation Guide - Setup instructions and dependencies</li> <li>Quick Start Tutorial - Run your first pyPFC simulation</li> <li>Examples - Comprehensive examples and use cases</li> <li>API Reference - Detailed class and method documentation</li> <li>Troubleshooting - Q&amp;A</li> </ol>"},{"location":"#licencing","title":"Licencing","text":"<p>This software is released under a GNU GPLv3 license.</p>"},{"location":"#references","title":"References","text":"<p>Further details on PFC modeling and example applications can be found in:</p> <ol> <li>K.H. Blixt and H. Hallberg, Phase Field Crystal Modeling of Grain Boundary Migration: Mobility, Energy and Structural Variability, Acta Materialia, 297:121318, 2025</li> <li>H. Hallberg and K.H. Blixt, Assessing grain boundary variability through phase field crystal simulations, Physical Review Materials, 8(3):113605, 2024</li> <li>K.H. Blixt and H. Hallberg, Phase field crystal modeling of grain boundary structures in diamond cubic systems, Physical Review Materials, 8(3):033606, 2024</li> <li>H. Hallberg and K.H. Blixt, Multiplicity of grain boundary structures and related energy variations, Materials Today Communications, 38:107724, 2024</li> <li>H. Hallberg and K.H. Blixt, Evaluation of Nanoscale Deformation Fields from Phase Field Crystal Simulations, Metals, 12(10):1630, 2022</li> <li>K.H. Blixt and H. Hallberg, Grain boundary and particle interaction: Enveloping and pass-through mechanisms studied by 3D phase field crystal simulations, Materials &amp; Design, 220:110845, 2022</li> <li>K.H. Blixt and H. Hallberg, Grain boundary stiffness based on phase field crystal simulations, Materials Letters, 318:132178, 2022</li> <li>K.H. Blixt and H. Hallberg, Evaluation of grain boundary energy, structure and stiffness from phase field crystal simulations, Modelling and Simulation in Materials Science and Engineering, 30(1):014002, 2022</li> </ol>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#examples","title":"Examples","text":"<p>This page provides an overview of examples included with pyPFC. The examples demonstrates different aspects of the simulation framework. Additional useful information is also provided:</p> <ul> <li>File Formats</li> <li>Indicative GPU Memory Requirements</li> <li>Performance Notes</li> <li>Recommended Configurations</li> <li>Customization</li> </ul>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<pre><code># Navigate to examples directory\ncd examples/\n\n# Run specific example\npython ex04_quick_start.py\n</code></pre>"},{"location":"examples/#example-0","title":"Example 0","text":"<p>Source Code: ex00_density_field.py</p> <p>Description: Investigate solid/liquid coexistence, interpolation of density field maxima and phase field evaluation. Output is written to VTK files and saved in pickle format for subsequent post-processing, for example, using Matplotlib.</p>"},{"location":"examples/#example-1","title":"Example 1","text":"<p>Source Code: ex01_grain_growth.py</p> <p>Description: Growth/solidification from a spherical nucleus. Data is saved to VTK and pickle formats. The example is suitable for performance benchmarking of different pyPFC parameter settings and of alternative hardware configurations.</p>"},{"location":"examples/#example-2","title":"Example 2","text":"<p>Source Code:  ex02_grain_boundary_migration.py</p> <p>Description: Simulation of selective grain growth in a bicrystal under an artificial driving pressure, controlled via a directional convolution kernel. Field averages are evluated and data is written to VTK and pickle files.</p>"},{"location":"examples/#example-3","title":"Example 3","text":"<p>Source Code:  ex03_polycrystal_solidification.py</p> <p>Description: A polycrystal is seeded in a large liquid domain and the simulation shows the subsequent polycrystal solidification process. Grain boundaries are formed and evolve during the process. Data is written to Extended XYZ format for post-processing.</p>"},{"location":"examples/#example-4","title":"Example 4","text":"<p>Source code: ex04_quick_start.py</p> <p>Description: Basic single crystal simulation, output is written in VTK format. The example is also found in the Quick Start Guide.</p>"},{"location":"examples/#example-5","title":"Example 5","text":"<p>Source code: ex05_structure_analysis.py</p> <p>Description: This is an example to illustrate the use of structure analysis by the centro-symmetry parameter (CSP) method in the pyPFC package and use of the class <code>pypfc_ovito</code>. The example demonstrates how to set up a simulation, generate an initial density field, evolve the density field over time, and perform structure analysis to identify defects in the crystal structure. The results are saved to VTK files for visualization.</p>"},{"location":"examples/#file-formats","title":"File Formats","text":"<p>pyPFC works with different file formats for data I/O:</p> Extension Description Viewer <code>.pickle</code> Binary Python pickle format Custom analysis using <code>pypfc.save_pickle()</code> and <code>pypfc.load_pickle()</code> <code>.txt</code> Standard ASCII text files Text editor <code>.vtp</code> VTK point data, binary XML format Can be opened in, for example, ParaView <code>.vts</code> VTK structured grid data, binary XML format Can be opened in, for example, ParaView <code>.xyz</code> Extended XYZ format Can be opened in, for example, OVITO"},{"location":"examples/#performance-notes","title":"Performance Notes","text":""},{"location":"examples/#indicative-gpu-memory-requirements-depending-on-floating-point-precision","title":"Indicative GPU Memory Requirements Depending on Floating-Point Precision","text":"Grid Size Memory (Single) Memory (Double) 64\u00b3 ~1 GB ~2 GB 128\u00b3 ~8 GB ~16 GB 256\u00b3 ~64 GB ~128 GB"},{"location":"examples/#recommended-configurations","title":"Recommended Configurations","text":"<p>For Testing (fast execution):</p> <pre><code>config = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'single',\n    'update_scheme': 'exponential',\n    'update_scheme_params': [2.0, 0.1]\n}\n</code></pre> <p>For Production (high accuracy):</p> <pre><code>config = {\n    'device_type': 'GPU',\n    'dtype_gpu': 'double',\n    'update_scheme': '2nd_order',\n    'update_scheme_params': [0.5, 0.001]\n}\n</code></pre>"},{"location":"examples/#customization","title":"Customization","text":"<p>All examples can be customized by modifying parameters:</p> <pre><code># Modify any example\ndomain_size = [custom_x, custom_y, custom_z]\nndiv        = [custom_nx, custom_ny, custom_nz]\nparams['your_parameter'] = your_value\n</code></pre> <p>For more advanced customization, see the API documentation.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation-guide","title":"Installation Guide","text":"<p>The following installation methods can be considered:</p>"},{"location":"installation/#method-1-local-installation","title":"Method 1: Local Installation","text":"<p>The simplest way to install pyPFC is via pip, which should ensure that the package dependencies are met automatically. Note, however, that PyTorch is only installed with CPU support since PyPI only provides the CPU version of torch. GPU support needs to be added manually.</p> <p>Install from PyPI using:</p> <pre><code>pip install pypfc\n</code></pre> <p>or</p> <pre><code>sudo pip install pypfc\n</code></pre> <p>Alternatively, install from source by:</p> <pre><code>git clone https://github.com/HHallb/pyPFC.git\ncd pyPFC\npip install .\n</code></pre> <p>Import pyPFC into your Python code by <code>import pypfc</code> and, optionally, <code>import pypfc_ovito</code>. See the Quick Start Tutorial or the examples provided in <code>./examples/</code>.</p>"},{"location":"installation/#method-2-development-installation","title":"Method 2: Development Installation","text":"<p>For development or if you want to modify the code:</p> <pre><code># Clone the repository\ngit clone https://github.com/HHallb/pyPFC.git\ncd pyPFC\n\n# Install in development mode\npip install -e .\n</code></pre>"},{"location":"installation/#method-3-direct-installation-from-github","title":"Method 3: Direct Installation from GitHub","text":"<pre><code>pip install git+https://github.com/HHallb/pyPFC.git\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>pyPFC automatically installs the following required packages:</p> <ul> <li>numpy</li> <li>scikit-image</li> <li>scipy</li> <li>torch</li> <li>vtk</li> </ul> <p>Note that PyPI only installs torch with CPU support. To add GPU support, refer to GPU support.</p>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For enhanced functionality, you may want to install:</p> <pre><code># For visualization and analysis\npip install matplotlib\n\n# For OVITO integration (optional)\npip install ovito\n\n# For Jupyter notebook examples\npip install jupyter ipywidgets\n</code></pre>"},{"location":"installation/#gpu-support","title":"GPU Support","text":""},{"location":"installation/#cuda-installation","title":"CUDA Installation","text":"<p>For GPU acceleration, install PyTorch with CUDA support:</p> <pre><code># For CUDA 11.8 (check your CUDA version)\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118\n\n# For CUDA 12.1\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121\n\n# For CPU-only (if no GPU available)\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu\n</code></pre> <p>For other CUDA versions and further information, please refer to the official PyTorch documentation.</p>"},{"location":"installation/#verify-gpu-support","title":"Verify GPU Support","text":"<pre><code>import torch\nprint(f\"CUDA available: {torch.cuda.is_available()}\")\nprint(f\"CUDA devices: {torch.cuda.device_count()}\")\nif torch.cuda.is_available():\n    print(f\"Current device: {torch.cuda.get_device_name()}\")\n</code></pre>"},{"location":"installation/#virtual-environment-recommended","title":"Virtual Environment (Recommended)","text":"<p>Use a virtual environment to avoid dependency conflicts:</p> <pre><code># Create virtual environment\npython -m venv pypfc_env\n\n# Activate (Linux/macOS)\nsource pypfc_env/bin/activate\n\n# Activate (Windows)\npypfc_env\\Scripts\\activate\n\n# Install pyPFC\npip install -e .\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify your installation:</p> <pre><code>import pypfc\nimport torch\nimport numpy as np\n\n# Test basic functionality\nsim = pypfc.setup_simulation([2,2,2])\nprint(\"pyPFC successfully imported!\")\n\n# Check versions\nprint(f\"PyTorch version: {torch.__version__}\")\nprint(f\"NumPy version: {np.__version__}\")\nprint(f\"CUDA available: {torch.cuda.is_available()}\")\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Quick Start Guide - Run your first simulation</li> <li>Examples - Explore pyPFC example</li> <li>API Documentation - Learn the API</li> </ol>"},{"location":"installation/#need-help","title":"Need Help?","text":"<p>Check the troubleshooting section.</p>"},{"location":"quick_start/","title":"Quick Start","text":""},{"location":"quick_start/#quick-start-guide","title":"Quick Start Guide","text":"<p>This guide will get you running your first pyPFC simulation in minutes.</p>"},{"location":"quick_start/#your-first-simulation","title":"Your First Simulation","text":"<p>This is a first quick start example for using the pyPFC package to perform a simple PFC simulation. It demonstrates how to set up a simulation, generate an initial density field, evolve the density field over time and save the results to VTK files for visualization. The simulation traces the growth of a spherical crystal, centered in a 3D periodic domain.</p> <p>Before running this script, ensure that you have the pyPFC package and its dependencies installed.</p> <pre><code>import pypfc\nimport numpy as np\n\n# Set simulation-specific parameters\nnstep       = 4000                      # Number of simulation steps\nnout        = 1000                      # Evaluate and save data in every nout:h step\noutput_path = './examples/ex04_output/' # Output path\n\n# Define the simulation box by setting the domain size \n# along the x, y and z axes, measured in lattice parameters\ndomain_size = [20, 20, 20]\n\n# Create a simulation object\nsim = pypfc.setup_simulation(domain_size)\n\n# Generate a spherical crystal with a specified radius (taken as a fraction of\n# the domain_size along x) at the center of the domain\nden = sim.do_single_crystal(params=[domain_size[0]*0.25])\n\n# Set the new density field in the pyPFC simulation object\nsim.set_density(den)\n\n# Evolve the PFC density field\nfor step in range(nstep):\n\n    # Update density\n    sim.do_step_update()\n\n    # Evaluate and save data at specified intervals\n    if np.mod(step+1,nout)==0 or step+1==nstep:\n\n        # Print the current step number to trace the simulation progress\n        print('Step: ', step+1)\n\n        # Evaluate data in the current step\n        den, _                = sim.get_density()                   # Retrieve the density field\n        atom_coord, atom_data = sim.interpolate_density_maxima(den) # Interpolate density maxima\n\n        # Save atom data to a VTK file\n        filename = output_path + 'pfc_data_' + str(step+1)\n        sim.write_vtk_points(filename, atom_coord, [atom_data[:,0]], ['den'])\n\n# Final cleanup\nsim.cleanup()\n</code></pre>"},{"location":"quick_start/#add-a-plot-of-the-pfc-energy","title":"Add a plot of the PFC energy","text":"<pre><code>import matplotlib as plt\n\n# Run simulation for 100 steps\nnstep = 100\nnout  = 10\nenergies = []\nsteps = []\n\nfor step in range(nstep):\n    # Update the system\n    sim.do_step_update()\n\n    # Monitor energy every nout:h step\n    if np.mod(step+1,nout)==0 or step+1==nstep:\n        energy = sim.get_energy()\n        energies.append(energy)\n        steps.append(step)\n        print(f\"Step {step:3d}: Energy = {energy:.6f}\")\n\n# Plot energy evolution\nplt.figure(figsize=(8, 5))\nplt.plot(steps, energies, 'b-o', linewidth=2, markersize=4)\nplt.xlabel('Simulation Step')\nplt.ylabel('Free Energy')\nplt.title('Energy Evolution')\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"quick_start/#next-step","title":"Next Step","text":"<p>Explore the comprehensive examples to see more of pyPFC's capabilities!</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter installation issues or errors when trying to run pyPFC, answers can hopefully be found below:</p>"},{"location":"troubleshooting/#i-have-a-nvidia-gpu-installed-but-pypfc-tells-me-i-dont","title":"I have a Nvidia GPU installed but pyPFC tells me I don't","text":"<p>Ensure that PyTorch is installed with CUDA enabled. To be sure, you can also check your setup by running:</p> <pre><code>import torch\nprint(torch.cuda.is_available())\nprint(torch.cuda.device_count())\nprint(torch.version.cuda)\n</code></pre> <p>If <code>is_available()</code> is <code>False</code> or <code>device_count()</code> is <code>0</code>, PyTorch cannot see your GPU. See the section on GPU support in the Installation Guide on how to enable CUDA.</p>"},{"location":"troubleshooting/#the-solid-crystal-phase-fails-to-stabilize-andor-appears-to-melt-away","title":"The solid crystal phase fails to stabilize and/or appears to \"melt\" away","text":"<p>This is most likely due to <code>domain_size</code> not being set correctly to accommodate the current lattice periodicity.</p>"},{"location":"troubleshooting/#the-atom-positions-obtained-by-interpolate_density_maxima-do-not-seem-to-coincide-with-the-density-field-maxima","title":"The atom positions obtained by <code>interpolate_density_maxima</code> do not seem to coincide with the density field maxima","text":"<p>This is likely related to either insufficient grid resolution or too low interpolation order. The former issue is mitigated by reducing the values in <code>ddiv</code> and in the latter case <code>density_interp_order</code> should be increased. Usually <code>density_interp_order=2</code> is fine and increasing the number will also increase the time spent on interpolation.</p>"},{"location":"troubleshooting/#importerror-no-module-named-pypfc","title":"ImportError: No module named 'pypfc'","text":"<p>Make sure you're in the correct environment and pyPFC is installed:</p> <pre><code>pip list | grep pypfc\n</code></pre>"},{"location":"troubleshooting/#cuda-out-of-memory","title":"CUDA Out of Memory","text":"<p>Reduce simulation size or use CPU:</p> <pre><code>params = {'device_type': 'CPU'}\ndomain_size = [size_x, size_y, size_z] # Consider reducing these numbers\npfc.setup_simulation(domain_size, config=params)\n</code></pre>"},{"location":"troubleshooting/#fft-errors","title":"FFT Errors","text":"<p>Ensure grid dimensions are even numbers (pyPFC should issue a warning if this is not the case):</p> <pre><code># Good: even dimensions\nndiv = [64, 64, 32]\n\n# Bad: odd dimensions\nndiv = [63, 65, 31]\n</code></pre>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#slow-simulations","title":"Slow Simulations","text":"<ol> <li>Enable GPU: Verify CUDA installation and GPU detection</li> <li>Grid Size: Start with smaller grids for testing</li> </ol>"},{"location":"troubleshooting/#memory-issues","title":"Memory Issues","text":"<ol> <li>Reduce Grid Size: Use a smaller simulation domain or reduce the number of grid points <code>ndiv</code></li> <li>Use Single Precision: Set <code>dtype_gpu: 'torch.float32'</code> and <code>dtype_cpu': 'np.single'</code></li> <li>Clear Device Cache: Call <code>torch.cuda.empty_cache()</code></li> </ol>"},{"location":"api/complete_api/","title":"Complete API Reference","text":"<p>Listing of all methods across all pyPFC classes.</p>"},{"location":"api/complete_api/#class-pypfc_grid","title":"Class pypfc_grid","text":""},{"location":"api/complete_api/#src.pypfc_grid.setup_grid.copy_from","title":"copy_from","text":"<pre><code>copy_from(grid: setup_grid) -&gt; None\n</code></pre> <p>Copy grid parameters from another grid object.</p> <p>This method copies all grid configuration parameters from another  setup_grid instance, including domain size, grid divisions, and derived parameters.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>setup_grid</code> <p>Another setup_grid instance to copy parameters from.</p> required"},{"location":"api/complete_api/#src.pypfc_grid.setup_grid.get_ddiv","title":"get_ddiv","text":"<pre><code>get_ddiv() -&gt; np.ndarray\n</code></pre> <p>Get the grid spacing in each direction.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Grid spacing [dx, dy, dz] for each coordinate axis.</p>"},{"location":"api/complete_api/#src.pypfc_grid.setup_grid.get_domain_size","title":"get_domain_size","text":"<pre><code>get_domain_size() -&gt; np.ndarray\n</code></pre> <p>Get the physical domain size in each direction.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Physical domain size [Lx, Ly, Lz] in lattice parameters.</p>"},{"location":"api/complete_api/#src.pypfc_grid.setup_grid.get_ndiv","title":"get_ndiv","text":"<pre><code>get_ndiv() -&gt; np.ndarray\n</code></pre> <p>Get the number of grid divisions in each direction.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Number of grid divisions [nx, ny, nz] along each axis.</p>"},{"location":"api/complete_api/#src.pypfc_grid.setup_grid.set_ddiv","title":"set_ddiv","text":"<pre><code>set_ddiv(ddiv: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the grid spacing in each direction.</p> <p>Parameters:</p> Name Type Description Default <code>ddiv</code> <code>array_like of float, shape (3,)</code> <p>Grid spacing in each direction [dx, dy, dz].</p> required"},{"location":"api/complete_api/#src.pypfc_grid.setup_grid.set_ndiv","title":"set_ndiv","text":"<pre><code>set_ndiv(ndiv: Union[List[int], ndarray]) -&gt; None\n</code></pre> <p>Set the number of grid divisions in each direction.</p> <p>Updates the grid division parameters and related grid point counts. All divisions must be even numbers for FFT compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>ndiv</code> <code>array_like of int, shape (3,)</code> <p>Number of grid divisions in each direction [nx, ny, nz].  Must be even numbers.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any value in ndiv is not an even number.</p>"},{"location":"api/complete_api/#class-pypfc_base","title":"Class pypfc_base","text":""},{"location":"api/complete_api/#src.pypfc_base.setup_base.evaluate_C2_d","title":"evaluate_C2_d","text":"<pre><code>evaluate_C2_d() -&gt; torch.Tensor\n</code></pre> <p>Establish the two-point correlation function for a crystal structure.</p> <p>Computes the two-point pair correlation function in Fourier space for the specified crystal structure using Gaussian peaks at  reciprocal lattice positions.</p> <p>Returns:</p> Name Type Description <code>C2_d</code> <code>(Tensor, shape(nx, ny, nz // 2 + 1))</code> <p>Two-point pair correlation function on the computational device.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If C20_alpha is negative when C20_amplitude is non-zero.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.evaluate_directional_correlation_kernel","title":"evaluate_directional_correlation_kernel","text":"<pre><code>evaluate_directional_correlation_kernel(\n    H0: ndarray, Rot: ndarray\n) -&gt; torch.Tensor\n</code></pre> <p>Establish directional correlation kernel for a crystal structure.</p> <p>Computes directional correlation kernels used in extended PFC models to introduce orientational dependence.</p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>float</code> <p>Constant modulation of the peak height.</p> required <code>Rot</code> <code>ndarray of float, shape (3, 3) or None</code> <p>Lattice rotation matrix. If None, uses identity matrix.</p> required <p>Returns:</p> Name Type Description <code>H_d</code> <code>(Tensor, shape(nx, ny, nz // 2 + 1))</code> <p>Directional correlation kernel on the computational device.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.evaluate_k2_d","title":"evaluate_k2_d","text":"<pre><code>evaluate_k2_d() -&gt; torch.Tensor\n</code></pre> <p>Evaluate the sum of squared wave vectors for FFT operations.</p> <p>Computes \\(k^2 = k_x^2 + k_y^2 + k_z^2\\) on the computational device using PyTorch FFT frequency grids. This is fundamental for Fourier-space operations in PFC simulations.</p> <p>Returns:</p> Name Type Description <code>k2_d</code> <code>(Tensor, shape(nx, ny, nz_half))</code> <p>Sum of squared wave vectors on the device. The z-dimension is  reduced due to real FFT symmetry (nz_half = nz//2 + 1).</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.evaluate_reciprocal_planes","title":"evaluate_reciprocal_planes","text":"<pre><code>evaluate_reciprocal_planes() -&gt; torch.Tensor\n</code></pre> <p>Establish reciprocal vectors/planes for a crystal structure.</p> <p>Computes reciprocal lattice plane spacing (d-spacing) and wave vectors for crystallographic planes. For cubic systems: d = a / sqrt(h\u00b2 + k\u00b2 + l\u00b2) where a is the lattice parameter, and reciprocal spacing is k = 2\u03c0/d.</p> <p>Returns:</p> Name Type Description <code>k_plane</code> <code>ndarray of float</code> <p>Reciprocal lattice plane spacings (wave vector magnitudes).</p> <code>n_plane</code> <code>ndarray of int</code> <p>Number of symmetrical planes in each family.</p> <code>den_plane</code> <code>ndarray of float</code> <p>Atomic density within each plane family.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the crystal structure is not supported.</p> <code>ValueError</code> <p>If there are not enough peaks defined for the requested number of peaks.</p> Notes <p>For any family of lattice planes separated by distance d, there are reciprocal lattice points at intervals of 2\u03c0/d in reciprocal space.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_alpha","title":"get_alpha","text":"<pre><code>get_alpha() -&gt; np.ndarray\n</code></pre> <p>Get the Gaussian peak widths for the two-point correlation function.</p> <p>Returns:</p> Name Type Description <code>alpha</code> <code>ndarray of float</code> <p>Gaussian peak widths (\u03b1_i) for each peak in the correlation function.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_csp","title":"get_csp","text":"<pre><code>get_csp(\n    pos: ndarray, normalize_csp: bool = False\n) -&gt; np.ndarray\n</code></pre> <p>Calculate the centro-symmetry parameter (CSP) for atoms.</p> <p>Computes CSP values for atoms in a 3D periodic domain to identify crystal defects and disorder. CSP quantifies deviation from centro-symmetric local environments.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray of float, shape (natoms, 3)</code> <p>3D coordinates of atoms.</p> required <code>normalize_csp</code> <code>bool</code> <p>If True, normalizes CSP values to range [0,1].</p> <code>False</code> <p>Returns:</p> Name Type Description <code>csp</code> <code>ndarray of float, shape (natoms,)</code> <p>Centro-symmetry parameter for each atom.</p> References <p>C.L. Kelchner, S.J. Plimpton and J.C. Hamilton, Dislocation nucleation and defect structure during surface indentation, Phys. Rev. B, 58(17):11085-11088, 1998. https://doi.org/10.1103/PhysRevB.58.11085</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_device_number","title":"get_device_number","text":"<pre><code>get_device_number() -&gt; int\n</code></pre> <p>Get the current GPU device number.</p> <p>Returns:</p> Type Description <code>int</code> <p>Current GPU device index.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_device_type","title":"get_device_type","text":"<pre><code>get_device_type() -&gt; str\n</code></pre> <p>Get the current computation device type.</p> <p>Returns:</p> Type Description <code>str</code> <p>Current device type ('CPU' or 'GPU').</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_dtype_cpu","title":"get_dtype_cpu","text":"<pre><code>get_dtype_cpu() -&gt; type\n</code></pre> <p>Get the current CPU data type.</p> <p>Returns:</p> Type Description <code>dtype</code> <p>Current NumPy data type used for CPU arrays.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_dtype_gpu","title":"get_dtype_gpu","text":"<pre><code>get_dtype_gpu() -&gt; torch.dtype\n</code></pre> <p>Get the current GPU data type.</p> <p>Returns:</p> Type Description <code>dtype</code> <p>Current PyTorch data type used for GPU tensors.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_field_average_along_axis","title":"get_field_average_along_axis","text":"<pre><code>get_field_average_along_axis(\n    field: ndarray, axis: int\n) -&gt; np.ndarray\n</code></pre> <p>Evaluate the mean value of a field variable along a specified axis.</p> <p>Computes the spatial average of a 3D field along one axis,  reducing the dimensionality by averaging over the other two axes.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>ndarray of float, shape (nx, ny, nz)</code> <p>3D field variable to be averaged.</p> required <code>axis</code> <code>str</code> <p>Axis to average along: x, y or z (case insensitive).</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>ndarray of float</code> <p>1D array containing mean values along the specified axis. Shape depends on the axis: (nx,), (ny,), or (nz,).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If axis is not x, y or z.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_integrated_field_along_axis","title":"get_integrated_field_along_axis","text":"<pre><code>get_integrated_field_along_axis(\n    field: ndarray, axis: int\n) -&gt; np.ndarray\n</code></pre> <p>Integrate a field variable along a specified axis.</p> <p>Performs numerical integration of a 3D field variable along one axis, integrating over the two orthogonal directions.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>ndarray of float, shape (nx, ny, nz)</code> <p>3D field variable to be integrated.</p> required <code>axis</code> <code>str</code> <p>Axis to integrate along: x, y or z (case insensitive).</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>ndarray of float</code> <p>1D array containing integrated values along the specified axis. Shape depends on the axis: (nx,), (ny,), or (nz,).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If axis is not x, y or z.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_integrated_field_in_volume","title":"get_integrated_field_in_volume","text":"<pre><code>get_integrated_field_in_volume(\n    field: ndarray, limits: Union[List[float], ndarray]\n) -&gt; float\n</code></pre> <p>Integrate a field variable within a defined volume.</p> <p>Performs numerical integration of a field variable over a specified 3D volume on a Cartesian grid.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>ndarray of float, shape (nx, ny, nz)</code> <p>Field to be integrated over the specified volume.</p> required <code>limits</code> <code>array_like of float, length 6</code> <p>Spatial integration limits: [xmin, xmax, ymin, ymax, zmin, zmax].</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>float</code> <p>Result of the volume integration.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_k","title":"get_k","text":"<pre><code>get_k(npoints: int, dspacing: float) -&gt; np.ndarray\n</code></pre> <p>Define a 1D wave vector for Fourier space operations.</p> <p>Parameters:</p> Name Type Description Default <code>npoints</code> <code>int</code> <p>Number of grid points. Must be even.</p> required <code>dspacing</code> <code>float</code> <p>Grid spacing in real space.</p> required <p>Returns:</p> Name Type Description <code>k</code> <code>ndarray of float</code> <p>1D wave vector array with proper frequency ordering for FFTs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If npoints is not an even number.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_k2_d","title":"get_k2_d","text":"<pre><code>get_k2_d() -&gt; torch.Tensor\n</code></pre> <p>Get the wave vector magnitude squared tensor.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>Wave vector magnitude squared (k\u00b2) tensor in Fourier space.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_phase_field_contour","title":"get_phase_field_contour","text":"<pre><code>get_phase_field_contour(\n    pf: Union[ndarray, Tensor],\n    pf_zoom: float = 1.0,\n    evaluate_volume: bool = True,\n) -&gt; Union[Tuple[np.ndarray, float], np.ndarray]\n</code></pre> <p>Find the iso-contour surface of a 3D phase field using marching cubes.</p> <p>Extracts iso-surfaces from 3D phase field data using the marching cubes algorithm, with optional volume calculation for enclosed regions.</p> <p>Parameters:</p> Name Type Description Default <code>pf</code> <code>ndarray of float, shape (nx, ny, nz)</code> <p>3D phase field data for iso-surface extraction.</p> required <code>pf_zoom</code> <code>float</code> <p>Zoom factor for spatial coarsening/refinement.</p> <code>1.0</code> <code>evaluate_volume</code> <code>bool</code> <p>If True, calculates the volume enclosed by the iso-surface.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>verts</code> <code>ndarray of float, shape (n_vertices, 3)</code> <p>Vertices of the iso-surface triangulation.</p> <code>faces</code> <code>ndarray of int, shape (n_faces, 3)</code> <p>Surface triangulation topology (vertex indices).</p> <code>volume</code> <code>(float, optional)</code> <p>Volume enclosed by the iso-surface (only if evaluate_volume=True).</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_rlv","title":"get_rlv","text":"<pre><code>get_rlv(struct: str, alat: float) -&gt; np.ndarray\n</code></pre> <p>Get the reciprocal lattice vectors for a crystal structure.</p> <p>Computes reciprocal lattice vectors for common crystal structures used in phase field crystal modeling.</p> <p>Parameters:</p> Name Type Description Default <code>struct</code> <code>str</code> <p>Crystal structure type. Options: 'SC', 'BCC', 'FCC', 'DC'.</p> required <code>alat</code> <code>float</code> <p>Lattice parameter.</p> required <p>Returns:</p> Name Type Description <code>rlv</code> <code>ndarray of float, shape (nrlv, 3)</code> <p>Reciprocal lattice vectors for the specified crystal structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the crystal structure is not supported.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_time_stamp","title":"get_time_stamp","text":"<pre><code>get_time_stamp() -&gt; str\n</code></pre> <p>Get current timestamp string.</p> <p>Returns:</p> Name Type Description <code>timestamp</code> <code>str</code> <p>Current date and time in format: YYYY-MM-DD HH:MM.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_torch_threads","title":"get_torch_threads","text":"<pre><code>get_torch_threads() -&gt; Tuple[int, int]\n</code></pre> <p>Get the current PyTorch thread configuration.</p> <p>Returns:</p> Type Description <code>tuple of int</code> <p>(num_threads, num_interop_threads) for PyTorch operations.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_verbose","title":"get_verbose","text":"<pre><code>get_verbose() -&gt; bool\n</code></pre> <p>Get the current verbose output setting.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Current verbose mode setting.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.get_xtal_nearest_neighbors","title":"get_xtal_nearest_neighbors","text":"<pre><code>get_xtal_nearest_neighbors() -&gt; (\n    Tuple[np.ndarray, np.ndarray]\n)\n</code></pre> <p>Get nearest neighbor information for crystal structures.</p> <p>Computes nearest neighbor distances and coordination numbers for common crystal structures used in phase field crystal modeling.</p> <p>Returns:</p> Name Type Description <code>nnb</code> <code>ndarray of int</code> <p>Number of nearest and next-nearest neighbors.</p> <code>nnb_dist</code> <code>ndarray of float</code> <p>Distances to the nearest and next-nearest neighbors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the crystal structure is not supported.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.interpolate_atoms","title":"interpolate_atoms","text":"<pre><code>interpolate_atoms(\n    intrp_pos: ndarray,\n    pos: ndarray,\n    values: ndarray,\n    num_nnb: int = 8,\n    power: int = 2,\n) -&gt; np.ndarray\n</code></pre> <p>Interpolate values at given positions using inverse distance weighting.</p> <p>Performs 3D interpolation in a periodic domain using inverse distance weighting: interpolated_value = \u03a3(wi \u00d7 vi) / \u03a3(wi), where wi = 1 / (di^power).</p> <p>Parameters:</p> Name Type Description Default <code>intrp_pos</code> <code>ndarray of float, shape (n_intrp, 3)</code> <p>3D coordinates of positions where values should be interpolated.</p> required <code>pos</code> <code>ndarray of float, shape (n_particles, 3)</code> <p>3D coordinates of particles with known values.</p> required <code>values</code> <code>ndarray of float, shape (n_particles,)</code> <p>Values at the particle positions to be interpolated.</p> required <code>num_nnb</code> <code>int</code> <p>Number of nearest neighbors to use for interpolation.</p> <code>8</code> <code>power</code> <code>float</code> <p>Power for inverse distance weighting.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>interp_val</code> <code>ndarray of float, shape (n_intrp,)</code> <p>Interpolated values at the specified positions.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.interpolate_density_maxima","title":"interpolate_density_maxima","text":"<pre><code>interpolate_density_maxima(\n    den: Union[ndarray, Tensor],\n    ene: Optional[Union[ndarray, Tensor]] = None,\n    pf: Optional[Union[ndarray, Tensor]] = None,\n) -&gt; Tuple[\n    np.ndarray, Optional[np.ndarray], Optional[np.ndarray]\n]\n</code></pre> <p>Find density field maxima and interpolate atomic positions and properties.</p> <p>Identifies local maxima in the density field as atomic positions and performs high-order interpolation to obtain sub-grid precision coordinates. Also  interpolates associated field values (density, energy, phase fields) at the atomic positions.</p> <p>Parameters:</p> Name Type Description Default <code>den</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field from PFC simulation.</p> required <code>ene</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Energy field for interpolation at atomic positions.</p> <code>None</code> <code>pf</code> <code>list of ndarray</code> <p>List of phase fields for interpolation at atomic positions. Each array should have shape (nx,ny,nz).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>atom_coord</code> <code>ndarray of float, shape (n_maxima,3)</code> <p>Interpolated coordinates of density maxima (atomic positions).</p> <code>atom_data</code> <code>ndarray of float, shape (n_maxima, 2+n_phase_fields)</code> <p>Interpolated field values at atomic positions. Columns: [density, energy, pf1, pf2, ..., pfN]</p> Notes <p>The method uses scipy.ndimage for high-order interpolation and applies density thresholding and merging of nearby maxima to remove spurious peaks. The interpolation order is controlled by the <code>_density_interp_order</code> attribute.</p>"},{"location":"api/complete_api/#src.pypfc_base.setup_base.set_alpha","title":"set_alpha","text":"<pre><code>set_alpha(alpha: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the Gaussian peak widths for the two-point correlation function.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>array_like of float</code> <p>Gaussian peak widths (\u03b1_i) for each peak in the correlation function.</p> required"},{"location":"api/complete_api/#src.pypfc_base.setup_base.set_device_number","title":"set_device_number","text":"<pre><code>set_device_number(device_number: int) -&gt; None\n</code></pre> <p>Set the GPU device number for multi-GPU systems.</p> <p>Parameters:</p> Name Type Description Default <code>device_number</code> <code>int</code> <p>GPU device index (0, 1, 2, ...) for CUDA computations.</p> required"},{"location":"api/complete_api/#src.pypfc_base.setup_base.set_device_type","title":"set_device_type","text":"<pre><code>set_device_type(device_type: str) -&gt; None\n</code></pre> <p>Set the computation device type.</p> <p>Parameters:</p> Name Type Description Default <code>device_type</code> <code>str</code> <p>Device type for computations. Options: 'CPU', 'GPU'.</p> required"},{"location":"api/complete_api/#src.pypfc_base.setup_base.set_dtype_cpu","title":"set_dtype_cpu","text":"<pre><code>set_dtype_cpu(dtype: type) -&gt; None\n</code></pre> <p>Set the CPU data type for numpy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>dtype</code> <p>NumPy data type for CPU computations (e.g., np.float32, np.float64).</p> required"},{"location":"api/complete_api/#src.pypfc_base.setup_base.set_dtype_gpu","title":"set_dtype_gpu","text":"<pre><code>set_dtype_gpu(dtype: dtype) -&gt; None\n</code></pre> <p>Set the GPU data type for PyTorch tensors.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>dtype</code> <p>PyTorch data type for GPU computations (e.g., torch.float32, torch.float64).</p> required"},{"location":"api/complete_api/#src.pypfc_base.setup_base.set_k2_d","title":"set_k2_d","text":"<pre><code>set_k2_d(k2_d: Tensor) -&gt; None\n</code></pre> <p>Set the wave vector magnitude squared tensor.</p> <p>Parameters:</p> Name Type Description Default <code>k2_d</code> <code>Tensor</code> <p>Wave vector magnitude squared (k\u00b2) tensor in Fourier space. Used for FFT-based operations and differential operators.</p> required"},{"location":"api/complete_api/#src.pypfc_base.setup_base.set_torch_threads","title":"set_torch_threads","text":"<pre><code>set_torch_threads(\n    nthreads: int, nthreads_interop: int\n) -&gt; None\n</code></pre> <p>Set PyTorch thread configuration for CPU operations.</p> <p>Parameters:</p> Name Type Description Default <code>nthreads</code> <code>int</code> <p>Number of threads for intra-op parallelism.</p> required <code>nthreads_interop</code> <code>int</code> <p>Number of threads for inter-op parallelism.</p> required"},{"location":"api/complete_api/#src.pypfc_base.setup_base.set_verbose","title":"set_verbose","text":"<pre><code>set_verbose(verbose: bool) -&gt; None\n</code></pre> <p>Set verbose output mode for debugging and monitoring.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, enables detailed timing and progress output.</p> required"},{"location":"api/complete_api/#class-pypfc_pre","title":"Class pypfc_pre","text":""},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.do_bicrystal","title":"do_bicrystal","text":"<pre><code>do_bicrystal(\n    xtal_rot: ndarray,\n    params: Optional[List[float]] = None,\n    liq_width: float = 0.0,\n    model: int = 0,\n) -&gt; np.ndarray\n</code></pre> <p>Define a bicrystal with two different crystal orientations.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>xtal_rot</code> <code>ndarray of float, shape (3,3,2)</code> <p>Crystal orientations (rotation matrices) for the two grains.</p> required <code>params</code> <code>list</code> <p>List containing parameters for the bicrystal model.</p> <ul> <li><code>model=0</code>: [r] - cylindrical crystal radius</li> <li><code>model=1</code>: [r] - spherical crystal radius</li> <li><code>model=2</code>: [gb_x1, gb_x2] - grain boundary positions along x</li> </ul> <code>None</code> <code>liq_width</code> <code>float</code> <p>Width of the liquid band along the grain boundary.</p> <code>0.0</code> <code>model</code> <code>int</code> <p>Density field layout.</p> <ul> <li>0: Cylindrical crystal, extending through z</li> <li>1: Spherical crystal  </li> <li>2: Bicrystal with two planar grain boundaries, normal to x</li> </ul> <code>0</code> <p>Returns:</p> Name Type Description <code>density</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value of <code>model</code> is not supported (should be 0, 1 or 2).</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.do_polycrystal","title":"do_polycrystal","text":"<pre><code>do_polycrystal(\n    xtal_rot: ndarray,\n    params: Optional[List[float]] = None,\n    liq_width: float = 0.0,\n    model: int = 0,\n) -&gt; np.ndarray\n</code></pre> <p>Define a polycrystal in a periodic 3D domain.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>xtal_rot</code> <code>ndarray of float, shape (3,3,n_xtal)</code> <p>Crystal orientations (rotation matrices) for n_xtal crystals.</p> required <code>params</code> <code>list</code> <p>List containing parameters for the polycrystal model.</p> <ul> <li><code>model=0</code>: No parameter needed. The number of crystal seeds is determined   from the number of provided orientations.</li> </ul> <code>None</code> <code>liq_width</code> <code>float</code> <p>Width of the liquid band along the grain boundaries.</p> <code>0.0</code> <code>model</code> <code>int</code> <p>Density field layout.</p> <ul> <li>0: A row of cylindrical seeds along y, with cylinders extending through z</li> </ul> <code>0</code> <p>Returns:</p> Name Type Description <code>density</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Polycrystal density field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value of <code>model</code> is not supported (should be 0).</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.do_single_crystal","title":"do_single_crystal","text":"<pre><code>do_single_crystal(\n    xtal_rot: Optional[ndarray] = None,\n    params: Optional[List[float]] = None,\n    model: int = 0,\n) -&gt; np.ndarray\n</code></pre> <p>Define a single crystal in a periodic 3D domain.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>xtal_rot</code> <code>ndarray of float, shape (3,3)</code> <p>Crystal orientation (rotation matrix). Default is an identity matrix.</p> <code>None</code> <code>params</code> <code>list</code> <p>List containing parameters for the single crystal model:</p> <ul> <li><code>model=0</code>: [r] - spherical crystal radius</li> <li><code>model=1</code>: [x1, x2] - crystal extent in x direction</li> <li><code>model=2</code>: [r] - cylindrical crystal radius</li> </ul> <code>None</code> <code>model</code> <code>(int, optional)</code> <p>Density field layout.</p> <ul> <li>0: Spherical crystal</li> <li>1: Crystal extending throughout y and z, covering interval in x</li> <li>2: Cylindrical crystal, extending through z</li> </ul> <code>0</code> <p>Returns:</p> Name Type Description <code>density</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value of <code>model</code> is not supported (should be 0 or 1).</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.evaluate_ampl_dens","title":"evaluate_ampl_dens","text":"<pre><code>evaluate_ampl_dens() -&gt; Tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Get density field amplitudes and phase densities for PFC simulations.</p> <p></p> <p>Returns:</p> Name Type Description <code>ampl</code> <code>ndarray of float, shape (npeaks,)</code> <p>Density field amplitudes for the specified crystal structure and  number of peaks.</p> <code>nLnS</code> <code>ndarray of float, shape (2,)</code> <p>Densities in the liquid (nL) and solid (nS) phases.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>npeaks</code> is not supported for the current crystal structure.</p> <code>ValueError</code> <p>If <code>sigma</code> value is not supported for the current configuration.</p> <code>ValueError</code> <p>If <code>struct</code> is not 'SC', 'BCC' or 'FCC' or if amplitudes and densities  are not available for the specified structure.</p> Notes <p>This method provides pre-calculated density field amplitudes and phase densities for different crystal structures (SC, BCC, FCC) and numbers of  Fourier peaks in the two-point correlation function. The values depend on the temperature-like parameter <code>sigma</code>.</p> <p>Fore efficiency, the method uses lookup tables of pre-computed values.</p> <p>Supported configurations:</p> <code>struct</code> <code>npeaks</code> <code>sigma</code> range SC 1 [0.0, 0.25] 2 [0.0, 0.22] 3 [0.0, 0.22] BCC 1 [0.0, 0.33] 2 [0.0, 0.30] 3 [0.0, 0.25] FCC 1 [0.0, 0.25] 2 [0.0, 0.25] 3 [0.0, 0.25]"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.generate_density_field","title":"generate_density_field","text":"<pre><code>generate_density_field(\n    crd: ndarray, g: ndarray\n) -&gt; np.ndarray\n</code></pre> <p>Define a 3D density field for (X)PFC modeling.</p> <p>Parameters:</p> Name Type Description Default <code>crd</code> <code>ndarray of float, shape (3,...)</code> <p>Grid point coordinates [x,y,z].</p> required <code>g</code> <code>ndarray of float, shape (3,3)</code> <p>Rotation matrix for crystal orientation.</p> required <p>Returns:</p> Name Type Description <code>density</code> <code>ndarray of float</code> <p>Density field for the specified crystal structure with appropriate Fourier modes and amplitudes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>struct</code> is not one of the supported crystal structures  ('SC', 'BCC', 'FCC', 'DC').</p> Notes <p>The density field is generated based on the current crystal structure  (<code>struct</code>) and density field amplitudes (<code>ampl</code>) settings.</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.get_ampl","title":"get_ampl","text":"<pre><code>get_ampl() -&gt; np.ndarray\n</code></pre> <p>Get the amplitudes in the density approximation.</p> <p>Returns:</p> Name Type Description <code>ampl</code> <code>ndarray of float, shape (N,)</code> <p>Amplitudes.</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.get_density","title":"get_density","text":"<pre><code>get_density() -&gt; np.ndarray\n</code></pre> <p>Get the density field.</p> <p>Returns:</p> Name Type Description <code>den</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field.</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.get_nlns","title":"get_nlns","text":"<pre><code>get_nlns() -&gt; np.ndarray\n</code></pre> <p>Get the liquid and solid phase densities.</p> <p>Returns:</p> Name Type Description <code>nlns</code> <code>ndarray of float, shape (2,)</code> <p>\\([n_{l},n_{s}]\\) where \\(n_{l}\\) is liquid phase density  and \\(n_{s}\\) is solid phase density.</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.get_npeaks","title":"get_npeaks","text":"<pre><code>get_npeaks() -&gt; int\n</code></pre> <p>Get the number of peaks in the density field approximation.</p> <p>Returns:</p> Name Type Description <code>npeaks</code> <code>int</code> <p>Number of peaks in the density field approximation.</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.get_sigma","title":"get_sigma","text":"<pre><code>get_sigma() -&gt; float\n</code></pre> <p>Get the temperature-like parameter sigma.</p> <p>Returns:</p> Name Type Description <code>sigma</code> <code>float</code> <p>Temperature-like parameter sigma</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.get_struct","title":"get_struct","text":"<pre><code>get_struct() -&gt; str\n</code></pre> <p>Get the crystal structure.</p> <p>Returns:</p> Name Type Description <code>struct</code> <code>str</code> <p>Crystal structure type: <code>'FCC'</code>, <code>'BCC'</code>.</p>"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.set_ampl","title":"set_ampl","text":"<pre><code>set_ampl(ampl: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the amplitudes in the density approximation.</p> <p>Parameters:</p> Name Type Description Default <code>ampl</code> <code>array_like of float, shape (N,)</code> <p>Amplitudes.</p> required"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.set_density","title":"set_density","text":"<pre><code>set_density(den: ndarray) -&gt; None\n</code></pre> <p>Set the density field.</p> <p>Parameters:</p> Name Type Description Default <code>den</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field.</p> required"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.set_energy","title":"set_energy","text":"<pre><code>set_energy(ene: ndarray) -&gt; None\n</code></pre> <p>Set the PFC energy field.</p> <p>Parameters:</p> Name Type Description Default <code>ene</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>PFC energy field.</p> required"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.set_nlns","title":"set_nlns","text":"<pre><code>set_nlns(nlns: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the liquid and solid phase densities.</p> <p>Parameters:</p> Name Type Description Default <code>nlns</code> <code>array_like of float, shape (2,)</code> <p>\\([n_{l},n_{s}]\\) where \\(n_{l}\\) is liquid phase density  and \\(n_{s}\\) is solid phase density.</p> required"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.set_npeaks","title":"set_npeaks","text":"<pre><code>set_npeaks(npeaks: int) -&gt; None\n</code></pre> <p>Set the number of peaks in the density field approximation.</p> <p>Parameters:</p> Name Type Description Default <code>npeaks</code> <code>int</code> <p>Number of peaks in the density field approximation.</p> required"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.set_sigma","title":"set_sigma","text":"<pre><code>set_sigma(sigma: float) -&gt; None\n</code></pre> <p>Set the temperature-like parameter sigma.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>float</code> <p>Temperature-like parameter sigma.</p> required"},{"location":"api/complete_api/#src.pypfc_pre.setup_pre.set_struct","title":"set_struct","text":"<pre><code>set_struct(struct: str) -&gt; None\n</code></pre> <p>Set the crystal structure.</p> <p>Parameters:</p> Name Type Description Default <code>struct</code> <code>(FCC, BCC)</code> <p>Crystal structure type: <code>'FCC'</code>, <code>'BCC'</code>.</p> <code>'FCC'</code>"},{"location":"api/complete_api/#class-pypfc_io","title":"Class pypfc_io","text":"<p>I/O operations for Phase Field Crystal simulation data.</p> <p>This class provides comprehensive file I/O functionality for PFC simulations including:</p> <ul> <li>Extended XYZ format for atomic positions and properties</li> <li>VTK output for visualization in ParaView/VisIt</li> <li>Binary pickle serialization for Python objects</li> <li>Structured grid data export for continuous fields</li> <li>Point data export for atomic/particle systems</li> <li>Simulation metadata and setup information files</li> </ul> <p>The class supports both text and binary formats, with optional compression for large datasets. All methods are designed to handle typical PFC simulation outputs including atomic positions, density fields, energy fields and phase field data.</p> Notes <p>The extended XYZ format follows the convention used in molecular dynamics and materials simulation communities, allowing storage of arbitrary per-atom properties alongside coordinates. VTK output enables direct visualization in scientific visualization software.</p>"},{"location":"api/complete_api/#src.pypfc_io.setup_io.append_to_info_file","title":"append_to_info_file","text":"<pre><code>append_to_info_file(\n    info: Union[str, List[str]],\n    filename: str = \"pypfc_simulation.txt\",\n    output_path: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Append information to a text file.</p> <p>Adds new content to an existing text file, useful for logging simulation progress or adding additional information to setup files.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>str or list of str</code> <p>String or list of strings to append to the file.</p> required <code>filename</code> <code>str</code> <p>Name of the output file.</p> <code>'pypfc_simulation.txt'</code> <code>output_path</code> <code>str</code> <p>Path to the output directory. Uses the current working directory as default.</p> <code>None</code>"},{"location":"api/complete_api/#src.pypfc_io.setup_io.load_pickle","title":"load_pickle","text":"<pre><code>load_pickle(filename: str, ndata: int) -&gt; List[Any]\n</code></pre> <p>Load data objects from a binary pickle file.</p> <p>Deserializes Python objects from a pickle file created with <code>save_pickle</code>. Reads a specified number of objects from the binary file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to input pickle file (without .pickle extension).</p> required <code>ndata</code> <code>int</code> <p>Number of data objects to read from the file.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>list</code> <p>List of Python objects loaded from <code>filename.pickle</code>.</p> Warning <p>Only load pickle files from trusted sources, as they can execute arbitrary code during deserialization.</p>"},{"location":"api/complete_api/#src.pypfc_io.setup_io.read_extended_xyz","title":"read_extended_xyz","text":"<pre><code>read_extended_xyz(\n    filename: str, nfields: int = 0\n) -&gt; Tuple[\n    np.ndarray, List[float], float, List[np.ndarray]\n]\n</code></pre> <p>Read PFC data from extended XYZ format file.</p> <p>Reads atomic positions and associated properties from an extended XYZ file, which may be compressed with gzip. Automatically detects file format and handles both .xyz and .xyz.gz extensions.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of input XYZ file (with or without .xyz/.xyz.gz extension).</p> required <code>nfields</code> <code>int</code> <p>Number of data fields per atom beyond coordinates [x,y,z].</p> <code>0</code> <p>Returns:</p> Name Type Description <code>coord</code> <code>ndarray of float, shape (natoms, 3)</code> <p>Atomic coordinates.</p> <code>domain_size</code> <code>ndarray of float, shape (3,)</code> <p>Domain size [Lx, Ly, Lz] from file header.</p> <code>time</code> <code>float</code> <p>Simulation time from file header.</p> <code>partDen</code> <code>ndarray of float, shape (natoms,)</code> <p>Particle density values (if available).</p> <code>partEne</code> <code>ndarray of float, shape (natoms,)</code> <p>Particle energy values (if available).</p> <code>partPf</code> <code>ndarray of float, shape (natoms,)</code> <p>Particle phase field values (if available).</p>"},{"location":"api/complete_api/#src.pypfc_io.setup_io.save_pickle","title":"save_pickle","text":"<pre><code>save_pickle(filename: str, data: List[Any]) -&gt; None\n</code></pre> <p>Save data objects to a binary pickle file.</p> <p>Serializes a list of Python objects to a binary pickle file for efficient storage and later retrieval. This is useful for saving simulation state, configuration parameters or processed results.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the output file (without .pickle extension).</p> required <code>data</code> <code>list</code> <p>List of Python objects to serialize and save.</p> required Notes <p>The output file will be named <code>filename.pickle</code>. Pickle files are Python-specific binary format that preserves object structure and types.</p> Warning <p>Only load pickle files from trusted sources, as they can execute arbitrary code during deserialization.</p>"},{"location":"api/complete_api/#src.pypfc_io.setup_io.write_extended_xyz","title":"write_extended_xyz","text":"<pre><code>write_extended_xyz(\n    filename: str,\n    coord: ndarray,\n    atom_data: List[ndarray],\n    atom_data_labels: List[str],\n    simulation_time: float = 0.0,\n    gz: bool = True,\n) -&gt; None\n</code></pre> <p>Save PFC atomic data in extended XYZ format.</p> <p>Writes atomic positions and associated properties to an extended XYZ file, which is a standard format in molecular dynamics and materials simulation. The format includes atomic coordinates plus arbitrary per-atom properties such as density, energy, phase field values, etc.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Base name of the output XYZ file (without extension).</p> required <code>coord</code> <code>ndarray of float, shape (natoms, 3)</code> <p>Atomic coordinates [x, y, z] for each atom.</p> required <code>atom_data</code> <code>list of ndarray</code> <p>List of arrays containing per-atom data. Each array must have shape (natoms,) and represent a property for each atom.</p> required <code>atom_data_labels</code> <code>list of str</code> <p>Labels for each data array in <code>atom_data</code>. Must have same length as <code>atom_data</code> list.</p> required <code>simulation_time</code> <code>float</code> <p>Simulation time to include in file header.</p> <code>0.0</code> <code>gz</code> <code>bool</code> <p>If <code>True</code>, compress output using gzip.</p> <code>True</code> Notes <p>The output file will be named <code>filename.xyz</code> or <code>filename.xyz.gz</code> if compression is enabled. The extended XYZ format includes a header with the number of atoms, simulation time, and property labels, followed by atomic coordinates and properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; write_extended_xyz('output', coord, [density, energy], \n...                   ['density', 'energy'], simulation_time=100.0)\n</code></pre>"},{"location":"api/complete_api/#src.pypfc_io.setup_io.write_info_file","title":"write_info_file","text":"<pre><code>write_info_file(\n    filename: str = \"pypfc_simulation.txt\",\n    output_path: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Write simulation setup information to a file.</p> <p>Creates a text file containing simulation parameters, grid configuration, and other setup information for documentation and reproducibility.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the output file.</p> <code>'pypfc_simulation.txt'</code> <code>output_path</code> <code>str</code> <p>Path to the output directory. Uses the current working directory as default.</p> <code>None</code>"},{"location":"api/complete_api/#src.pypfc_io.setup_io.write_vtk_points","title":"write_vtk_points","text":"<pre><code>write_vtk_points(\n    filename: str,\n    coord: ndarray,\n    scalar_data: List[ndarray],\n    scalar_data_name: List[str],\n    vector_data: Optional[List[ndarray]] = None,\n    vector_data_name: Optional[List[str]] = None,\n    tensor_data: Optional[List[ndarray]] = None,\n    tensor_data_name: Optional[List[str]] = None,\n) -&gt; None\n</code></pre> <p>Save 3D point data to VTK file for visualization.</p> <p>Exports atomic positions and associated scalar, vector and tensor data to a VTK (Visualization Toolkit) file in binary XML format. This format is compatible with ParaView, VisIt and other scientific visualization software.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output file name (with or without .vtu extension).</p> required <code>coord</code> <code>ndarray of float, shape (natoms, 3)</code> <p>3D coordinates of points/atoms.</p> required <code>scalar_data</code> <code>list of ndarray</code> <p>List of scalar data arrays. Each array should have shape (natoms,).</p> required <code>scalar_data_name</code> <code>list of str</code> <p>Names/labels for each scalar data array. Must match length of <code>scalarData</code>.</p> required <code>vector_data</code> <code>list of ndarray</code> <p>List of vector data arrays. Each array should have shape (natoms, 3).</p> <code>None</code> <code>vector_data_name</code> <code>list of str</code> <p>Names/labels for each vector data array. Required if <code>vectorData</code> is provided.</p> <code>None</code> <code>tensor_data</code> <code>list of ndarray</code> <p>List of tensor data arrays. Each array should have shape (natoms, 3, 3). Tensors are automatically reshaped to VTK format (natoms, 9).</p> <code>None</code> <code>tensor_data_name</code> <code>list of str</code> <p>Names/labels for each tensor data array. Required if <code>tensorData</code> is provided.</p> <code>None</code> Notes <p>Tensor data is reshaped from (3,3) matrices to 9-component vectors following VTK convention:</p> \\[T = \\begin{bmatrix}  T_{11} &amp; T_{12} &amp; T_{13} \\\\ T_{21} &amp; T_{22} &amp; T_{23} \\\\ T_{31} &amp; T_{32} &amp; T_{33}  \\end{bmatrix}\\] <p>becomes: \\([T_{11}, T_{12}, T_{13}, T_{21}, T_{22}, T_{23}, T_{31}, T_{32}, T_{33}]\\)</p>"},{"location":"api/complete_api/#src.pypfc_io.setup_io.write_vtk_structured_grid","title":"write_vtk_structured_grid","text":"<pre><code>write_vtk_structured_grid(\n    filename: str,\n    array_data: List[ndarray],\n    array_name: List[str],\n) -&gt; None\n</code></pre> <p>Save 3D field data to VTK structured grid file.</p> <p>Exports 3D field data (such as density, energy, or phase fields) to a  VTK structured grid file in binary XML format. This format is ideal for visualizing continuous field data in ParaView, VisIt and other  scientific visualization software.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output file name (with or without .vts extension).</p> required <code>array_data</code> <code>list of ndarray</code> <p>List of 3D numpy arrays containing field data. Each array should have shape (nx, ny, nz) matching the simulation grid.</p> required <code>array_name</code> <code>list of str</code> <p>Names/labels for each data array. Must match length of <code>arrayData</code>.</p> required Notes <p>The output file will be named <code>filename.vts</code> and uses VTK's structured grid format with binary encoding for efficient storage. The grid  dimensions and spacing are automatically determined from the inherited grid setup.</p>"},{"location":"api/complete_api/#class-pypfc","title":"Class pypfc","text":"<p>This is the primary class for conducting PFC simulations, providing complete functionality for time evolution, energy evaluation, and phase field analysis. It combines all inherited capabilities from the class hierarchy:</p> <ul> <li>Grid setup and domain discretization (pypfc_grid)</li> <li>Mathematical operations and device management (pypfc_base)  </li> <li>Density field generation and crystal structures (pypfc_pre)</li> <li>File I/O operations and data export (pypfc_io)</li> </ul> <p>The class uses a configuration-driven approach where all simulation parameters are managed through a DEFAULTS dictionary. User configurations merge with defaults, to provide parameter handling with fallback values.</p> Notes <p>All grid divisions (ndiv) must be even numbers for FFT compatibility. The class automatically validates configuration parameters and provides informative error messages for invalid inputs.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.cleanup","title":"cleanup","text":"<pre><code>cleanup() -&gt; None\n</code></pre> <p>Clean up allocated tensors and free device memory.</p> <p>Explicitly deletes PyTorch tensors to free GPU/CPU memory. This is particularly important for GPU simulations to prevent memory leaks and ensure proper resource management.</p> Notes <p>This method should be called at the end of simulations, especially when running multiple simulations sequentially or when GPU memory is limited. The method automatically detects which tensors exist based on the update scheme and cleans up accordingly.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.do_step_update","title":"do_step_update","text":"<pre><code>do_step_update() -&gt; None\n</code></pre> <p>Update the PFC density field using the selected time integration scheme.</p> <p>Performs one time step of the PFC evolution equation using the time integration method specified by <code>_update_scheme</code>. The method operates in Fourier space for computational efficiency and automatically handles the FFT/iFFT transformations.</p> <p>Returns:</p> Name Type Description <code>f_den_d</code> <code>Tensor</code> <p>Updated density field in Fourier space. The real-space density field is automatically updated in <code>self._den_d</code> via inverse FFT.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified update_scheme is not supported.</p> Notes <p>This method uses precomputed linear terms for efficiency. The appropriate update method is selected based on <code>self._update_scheme</code> and called with the corresponding precomputed Fourier-space operators.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.evaluate_energy","title":"evaluate_energy","text":"<pre><code>evaluate_energy() -&gt; float\n</code></pre> <p>Evaluate the PFC energy.</p> <p>Computes the total free energy of the system using the phase field crystal energy functional.</p> <p>Returns:</p> Name Type Description <code>ene</code> <code>Tensor</code> <p>Energy field with shape [nx, ny, nz].</p> <code>eneAv</code> <code>float</code> <p>Average free energy density.</p> Notes <p>Energy is computed in Fourier space for efficiency and transformed back to real space for local energy density visualization.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.get_C2_d","title":"get_C2_d","text":"<pre><code>get_C2_d() -&gt; torch.Tensor\n</code></pre> <p>Get the current two-point correlation function.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>Two-point correlation function in Fourier space.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.get_alat","title":"get_alat","text":"<pre><code>get_alat() -&gt; float\n</code></pre> <p>Get the current lattice parameter.</p> <p>Returns:</p> Type Description <code>float</code> <p>Current lattice parameter value.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.get_alpha","title":"get_alpha","text":"<pre><code>get_alpha() -&gt; np.ndarray\n</code></pre> <p>Get the current alpha parameters.</p> <p>Returns:</p> Type Description <code>float</code> <p>Current alpha parameter values.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.get_density","title":"get_density","text":"<pre><code>get_density() -&gt; np.ndarray\n</code></pre> <p>Get the PFC density field and its mean value.</p> <p>Returns the current density field and its spatial average, transferring data from GPU to CPU if necessary.</p> <p>Returns:</p> Name Type Description <code>den</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field on CPU.</p> <code>mean_den</code> <code>float</code> <p>Spatially averaged density.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.get_dtime","title":"get_dtime","text":"<pre><code>get_dtime() -&gt; float\n</code></pre> <p>Get the current time step size.</p> <p>Returns:</p> Type Description <code>float</code> <p>Current time step size for integration.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.get_energy","title":"get_energy","text":"<pre><code>get_energy() -&gt; np.ndarray\n</code></pre> <p>Get the PFC energy field and its mean value.</p> <p>Computes the local energy density field and its spatial average using the current density field configuration.</p> <p>Returns:</p> Name Type Description <code>ene</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Local energy density field on CPU.</p> <code>mean_ene</code> <code>float</code> <p>Spatially averaged energy density.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.get_phase_field","title":"get_phase_field","text":"<pre><code>get_phase_field() -&gt; Union[np.ndarray, List[np.ndarray]]\n</code></pre> <p>Evaluate phase field using wavelet filtering.</p> <p>Computes the phase field by applying wavelet convolution followed by Gaussian smoothing. The phase field identifies crystalline regions and their orientations within the PFC density field.</p> <p>Returns:</p> Name Type Description <code>pf</code> <code>ndarray of float, shape (nx,ny,nz) or list of such arrays</code> <p>Phase field(s) on CPU. Returns a single array for isotropic kernels or a list of arrays for directional analysis with multiple kernels.</p> Notes <p>The method automatically handles both single and multiple wavelet kernels for comprehensive grain orientation analysis.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.get_update_scheme","title":"get_update_scheme","text":"<pre><code>get_update_scheme() -&gt; str\n</code></pre> <p>Establish the PFC time integration scheme and return method handle.</p> <p>Configures the selected time integration scheme and returns a function handle to the appropriate update method. This method sets up scheme-specific parameters and precomputed terms for efficient time stepping.</p> <p>Returns:</p> Name Type Description <code>update_density</code> <code>callable</code> <p>Function handle to the selected time integration method.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If alpha, beta, gamma parameters are not provided for '2nd_order' scheme.</p> <code>ValueError</code> <p>If f_denOld_d is not provided for '2nd_order' scheme.</p> <code>ValueError</code> <p>If the specified update_scheme is not supported.</p> Notes <p>The method automatically precomputes linear terms in Fourier space to optimize performance during time stepping. Different schemes require different numbers of precomputed terms and have varying stability properties and computational costs.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.get_update_scheme_params","title":"get_update_scheme_params","text":"<pre><code>get_update_scheme_params() -&gt; np.ndarray\n</code></pre> <p>Get the current integration scheme parameters.</p> <p>Returns:</p> Type Description <code>array_like</code> <p>Current parameters for the time integration scheme.</p>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_C2_d","title":"set_C2_d","text":"<pre><code>set_C2_d(C2_d: Tensor) -&gt; None\n</code></pre> <p>Set the two-point correlation function in Fourier space.</p> <p>Parameters:</p> Name Type Description Default <code>C2_d</code> <code>Tensor</code> <p>Two-point correlation function tensor in Fourier space. Must match the grid dimensions and be on the correct device.</p> required"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_H2","title":"set_H2","text":"<pre><code>set_H2(H0: float, Rot: ndarray) -&gt; None\n</code></pre> <p>Set the directional correlation kernel for extended PFC models.</p> <p>Configures the H2 kernel used in extended phase field crystal models to introduce directional correlations.</p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>float</code> <p>Amplitude of the directional correlation kernel.</p> required <code>Rot</code> <code>array_like or None</code> <p>Rotation matrix for orienting the kernel. If None, uses identity orientation.</p> required"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_alat","title":"set_alat","text":"<pre><code>set_alat(alat: float) -&gt; None\n</code></pre> <p>Set the lattice parameter.</p> <p>Parameters:</p> Name Type Description Default <code>alat</code> <code>float</code> <p>Lattice parameter.</p> required"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_alpha","title":"set_alpha","text":"<pre><code>set_alpha(alpha: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the alpha parameters, controlling the widths of the Gaussian peaks of the pair correlation function.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Pair correlation peak widths.</p> required"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_density","title":"set_density","text":"<pre><code>set_density(density: ndarray) -&gt; None\n</code></pre> <p>Set the PFC density field.</p> <p>Updates the density field and automatically computes its Fourier transform for subsequent calculations.</p> <p>Parameters:</p> Name Type Description Default <code>density</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>New density field configuration.</p> required"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_dtime","title":"set_dtime","text":"<pre><code>set_dtime(dtime: float) -&gt; None\n</code></pre> <p>Set the time step.</p> <p>Parameters:</p> Name Type Description Default <code>dtime</code> <code>float</code> <p>Time step size. Must be positive and small enough for stability.</p> required"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_phase_field_kernel","title":"set_phase_field_kernel","text":"<pre><code>set_phase_field_kernel(\n    H0: float = 1.0,\n    Rot: Optional[Union[ndarray, List[ndarray]]] = None,\n) -&gt; None\n</code></pre> <p>Set phase field kernel for directional analysis.</p> <p>Configures the correlation kernel used for phase field evaluation, allowing for directional filtering or isotropic analysis.</p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>float</code> <p>Kernel amplitude.</p> <code>1.0</code> <code>Rot</code> <code>ndarray of float, shape (3,3)</code> <p>Rotation matrix for directional kernel. If <code>None</code>, uses isotropic two-point correlation function.</p> <code>None</code>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_phase_field_smoothing_kernel","title":"set_phase_field_smoothing_kernel","text":"<pre><code>set_phase_field_smoothing_kernel(\n    pf_gauss_var: Optional[float] = None,\n) -&gt; None\n</code></pre> <p>Set phase field smoothing kernel.</p> <p>Configures Gaussian smoothing parameters for phase field calculations.</p> <p>Parameters:</p> Name Type Description Default <code>pf_gauss_var</code> <code>float</code> <p>Gaussian variance for smoothing kernel. If <code>None</code>, uses current value.</p> <code>None</code>"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_update_scheme","title":"set_update_scheme","text":"<pre><code>set_update_scheme(update_scheme: str) -&gt; None\n</code></pre> <p>Set the time integration scheme for density evolution.</p> <p>Parameters:</p> Name Type Description Default <code>update_scheme</code> <code>str</code> <p>Time integration method. Options: '1st_order', '2nd_order',  'exponential'.</p> required"},{"location":"api/complete_api/#src.pypfc.setup_simulation.set_update_scheme_params","title":"set_update_scheme_params","text":"<pre><code>set_update_scheme_params(\n    params: Union[List[float], ndarray],\n) -&gt; None\n</code></pre> <p>Set parameters for the time integration scheme.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>array_like</code> <p>Parameters specific to the chosen integration scheme. Format depends on the selected scheme type.</p> required"},{"location":"api/complete_api/#class-pypfc_ovito","title":"Class pypfc_ovito","text":""},{"location":"api/complete_api/#src.pypfc_ovito.setup.do_ovito_csp","title":"do_ovito_csp","text":"<pre><code>do_ovito_csp(num_neighbors: int = 12) -&gt; np.ndarray\n</code></pre> <p>Evaluate the Centro-Symmetry Parameter (CSP) for each atom using OVITO.</p> <p>The CSP value is a useful measure for identifying defects in crystal structures.  Lower values indicate more perfect crystal structure.</p> <p>Parameters:</p> Name Type Description Default <code>num_neighbors</code> <code>int</code> <p>Number of nearest neighbors to consider for CSP calculation.</p> <ul> <li>FCC structure: 12</li> <li>BCC structure: 8</li> </ul> <code>12</code> <p>Returns:</p> Name Type Description <code>csp_values</code> <code>(ndarray, shape(N))</code> <p>Array of CSP values for each atom.</p> References <p>A. Stukowski (2010), Visualization and analysis of atomistic simulation data with OVITO - the Open Visualization Tool, Modelling Simul. Mater. Sci. Eng. 18, 015012. https://doi.org/10.1088/0965-0393/18/1/015012</p> <p>C.L. Kelchner, S.J. Plimpton and J.C. Hamilton, Dislocation nucleation and defect structure during surface indentation, Phys. Rev. B, 58(17):11085-11088, 1998. https://doi.org/10.1103/PhysRevB.58.11085</p>"},{"location":"api/complete_api/#src.pypfc_ovito.setup.do_ovito_dxa","title":"do_ovito_dxa","text":"<pre><code>do_ovito_dxa(\n    rep: Union[List[int], ndarray] = [1, 1, 1],\n    tol: float = 1e-08,\n) -&gt; Tuple[\n    np.ndarray,\n    np.ndarray,\n    np.ndarray,\n    np.ndarray,\n    np.ndarray,\n    List[np.ndarray],\n]\n</code></pre> <p>Perform dislocation analysis using OVITO's Dislocation eXtraction Algorithm (DXA).</p> <p>Parameters:</p> Name Type Description Default <code>rep</code> <code>array_like of int, shape (3,)</code> <p>Number of simulation box replications to consider in the periodic directions:  [n_rep_x, n_rep_y, n_rep_z]. Default is no replication.</p> <code>[1, 1, 1]</code> <code>tol</code> <code>float</code> <p>Tolerance parameter for dislocation type identification.</p> <code>1e-08</code> <p>Returns:</p> Name Type Description <code>disl_type_ids</code> <code>ndarray of int, shape (N,)</code> <p>Array of dislocation type IDs:</p> <ul> <li>0: \\(\\langle 100\\rangle\\) Composite</li> <li>1: \\(\\frac{1}{2}\\langle 110\\rangle\\) Perfect edge</li> <li>2: \\(\\frac{1}{6}\\langle 112\\rangle\\) Shockley screw</li> <li>3: \\(\\frac{1}{6}\\langle 110\\rangle\\) Stair-rod</li> <li>4: \\(\\frac{1}{3}\\langle 100\\rangle\\) Hirth</li> <li>5: \\(\\frac{1}{3}\\langle 111\\rangle\\) Frank</li> <li>6: other</li> </ul> <code>disl_coord</code> <code>ndarray of float, shape (N,3)</code> <p>Coordinates of the first point of each dislocation line.</p> <code>disl_line_len</code> <code>ndarray of float, shape (N,)</code> <p>Array of dislocation line lengths.</p> <code>disl_line_dir</code> <code>ndarray of float, shape (N,3)</code> <p>Array of dislocation line direction unit vectors.</p> <code>disl_burg_vec</code> <code>ndarray of float, shape (N,3)</code> <p>Array of Burgers vectors.</p> <code>disl_segm_pts</code> <code>ndarray of int, shape (N,)</code> <p>List of dislocation segment points.</p> References <p>A. Stukowski, V.V. Bulatov and A. Arsenlis (2012), Automated identification and indexing of dislocations in crystal interfaces, Modelling Simul. Mater. Sci. Eng. 20, 085007. https://doi.org/10.1088/0965-0393/20/8/085007</p>"},{"location":"api/complete_api/#src.pypfc_ovito.setup.do_ovito_ptm","title":"do_ovito_ptm","text":"<pre><code>do_ovito_ptm(\n    ref_rot: Optional[ndarray] = None,\n    output_euler_ang: bool = False,\n    output_strain: bool = False,\n) -&gt; Union[\n    Tuple[np.ndarray, np.ndarray],\n    Tuple[np.ndarray, np.ndarray, np.ndarray],\n]\n</code></pre> <p>Evaluate crystal structure, crystallographic orientation and elastic strain tensor using OVITO's Polyhedral Template Matching (PTM) algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>ref_rot</code> <code>array_like of float, shape (3,3)</code> <p>Reference rotation matrix.</p> <code>None</code> <code>output_euler_ang</code> <code>bool</code> <p>Format of output orientation representation:</p> <ul> <li><code>True</code>: Euler angles (ZXZ convention).</li> <li><code>False</code>: Quaternions. This is the default.</li> </ul> <code>False</code> <code>output_strain</code> <code>bool</code> <p>Whether to evaluate the local elastic Green-Lagrange strain tensors:</p> <ul> <li><code>True</code>: Compute strain tensors for each atom.</li> <li><code>False</code>: Skip strain calculation.</li> </ul> <code>False</code> <p>Returns:</p> Name Type Description <code>structure_id</code> <code>ndarray of int, shape (N,)</code> <p>Integer array of structure types per atom:</p> <ul> <li>0: Other/Unknown</li> <li>1: FCC (face-centered cubic)</li> <li>2: HCP (hexagonal close-packed)</li> <li>3: BCC (body-centered cubic)</li> <li>4: ICO (icosahedral coordination)</li> <li>5: SC (simple cubic)</li> <li>6: Cubic diamond</li> <li>7: Hexagonal diamond</li> <li>8: Graphene</li> </ul> <code>rot</code> <code>ndarray of float, shape (N,3) or (N,4)</code> <p>Local crystal orientation expressed as Euler angles or quaternions,  saved per atom as \\([\\varphi_{1}, \\Psi, \\varphi_{2}]\\) or (if <code>output_euler_ang=True</code>).</p> <code>strain</code> <code>ndarray of float, shape (N,6)</code> <p>Local Green-Lagrange strain tensor (if <code>output_strain=True</code>),  saved per atom as \\([\\epsilon_{xx}, \\epsilon_{yy}, \\epsilon_{zz}, \\epsilon_{xy}, \\epsilon_{xz}, \\epsilon_{yz}]\\).</p> References <p>P.M. Larsen et al. (2016), Robust Structural Identification via Polyhedral Template Matching, Modelling Simul. Mater. Sci. Eng. 24, 055007. https://doi.org/10.1088/0965-0393/24/5/055007</p> <p>A. Stukowski (2010), Visualization and analysis of atomistic simulation data with OVITO - the Open Visualization Tool, Modelling Simul. Mater. Sci. Eng. 18, 015012. https://doi.org/10.1088/0965-0393/18/1/015012</p>"},{"location":"api/complete_api/#src.pypfc_ovito.setup.get_coord","title":"get_coord","text":"<pre><code>get_coord() -&gt; np.ndarray\n</code></pre> <p>Get atom coordinates.</p> <p>Returns:</p> Name Type Description <code>coord</code> <code>ndarray of float, shape (N,3)</code> <p>Atom (x, y, z) coordinates.</p>"},{"location":"api/complete_api/#src.pypfc_ovito.setup.get_struct","title":"get_struct","text":"<pre><code>get_struct() -&gt; str\n</code></pre> <p>Get crystal structure type.</p> <p>Returns:</p> Name Type Description <code>struct</code> <code>str</code> <p>Crystal structure type: <code>'FCC'</code>, <code>'BCC'</code>.</p>"},{"location":"api/complete_api/#src.pypfc_ovito.setup.set_coord","title":"set_coord","text":"<pre><code>set_coord(coord: ndarray) -&gt; None\n</code></pre> <p>Set atom coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coord</code> <code>ndarray of float, shape (N,3)</code> <p>Atom (x, y, z) coordinates.</p> required"},{"location":"api/complete_api/#src.pypfc_ovito.setup.set_struct","title":"set_struct","text":"<pre><code>set_struct(struct: str) -&gt; None\n</code></pre> <p>Set crystal structure type.</p> <p>Parameters:</p> Name Type Description Default <code>struct</code> <code>(FCC, BCC)</code> <p>Crystal structure type: <code>'FCC'</code>, <code>'BCC'</code>.</p> <code>'FCC'</code>"},{"location":"api/complete_api/#src.pypfc_ovito.setup.set_verbose","title":"set_verbose","text":"<pre><code>set_verbose(verbose: bool) -&gt; None\n</code></pre> <p>Set verbose output mode.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Provide verbose output, or not.</p> required"},{"location":"api/core/","title":"Overview","text":""},{"location":"api/core/#core-classes","title":"Core Classes","text":"<p>This section documents the core classes, the structure and the coding conventions of the pyPFC framework.</p>"},{"location":"api/core/#code-conventions","title":"Code Conventions","text":""},{"location":"api/core/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>A variable with a trailing <code>_d</code> indicates a quantity residing on the <code>device</code>, which can be either <code>cpu</code> or <code>gpu</code>.</li> <li>A variable name with a leading <code>f_</code> indicates a complex-type quantity that is set in Fourier space.</li> <li>Names of variables, functions and methods, etc., follow the snake case convention, with words in lower-case letters, separated by underscores. For example: <code>a_variable_name</code></li> <li>Private methods and attributes should start with a single underscore: <code>_internal_method()</code></li> </ul>"},{"location":"api/core/#memory-and-performance","title":"Memory and Performance","text":"<ul> <li>Floating point precision of variables is declared by the class variables <code>dtype_cpu</code> and <code>dtype_gpu</code> for quantities residing on the <code>cpu</code> and <code>gpu</code>, respectively. This permits easy control of the overall precision used in a pyPFC simulation.</li> <li>Use in-place tensor operations when possible to minimize memory allocation: <code>tensor.add_(other)</code> instead of <code>tensor + other</code></li> <li>Ensure all PyTorch tensors are contiguous for optimal FFT performance: <code>tensor.contiguous()</code></li> <li>Free GPU memory explicitly in long-running simulations: <code>torch.cuda.empty_cache()</code></li> </ul>"},{"location":"api/core/#error-handling-and-validation","title":"Error Handling and Validation","text":"<ul> <li>Input parameters should be validated (e.g., an even number of grid divisions)</li> <li>Use descriptive error messages that include context and suggested solutions</li> <li>Raise appropriate exception types: <code>ValueError</code> for invalid parameters, <code>RuntimeError</code> for computational failures</li> <li>Include parameter bounds checking for physical quantities (e.g., positive time steps, reasonable grid sizes)</li> </ul>"},{"location":"api/core/#physical-units-and-dimensionality","title":"Physical Units and Dimensionality","text":"<ul> <li>All spatial dimensions are expressed in units of the lattice parameter (non-dimensional)</li> <li>Time evolution occurs in non-dimensional time units</li> <li>Document the physical interpretation of non-dimensional parameters in docstrings</li> <li>Use meaningful variable names that reflect physical quantities (e.g., <code>time_step</code>)</li> </ul>"},{"location":"api/core/#code-organization","title":"Code Organization","text":"<ul> <li>Keep functions focused on a single responsibility (single responsibility principle)</li> <li>Limit function length when possible for readability</li> <li>Group related functionality into logical class hierarchies following the inheritance chain</li> <li>Separate configuration parameters from computational code</li> <li>Use type hints for all function parameters and return values:</li> </ul> <pre><code>def evolve_field(density: torch.Tensor, time_step: float) -&gt; torch.Tensor:\n</code></pre>"},{"location":"api/core/#testing-and-reproducibility","title":"Testing and Reproducibility","text":"<ul> <li>Include assertions for critical computational assumptions</li> <li>Provide deterministic behavior when possible (set random seeds if using random numbers)</li> <li>Write functions that can be easily unit tested (avoid deep side effects)</li> <li>Include numerical tolerance checks for floating-point comparisons:</li> </ul> <pre><code>  assert torch.allclose(result, expected, rtol=1e-6, atol=1e-9)\n</code></pre>"},{"location":"api/core/#scientific-computing-best-practices","title":"Scientific Computing Best Practices","text":"<ul> <li>Prefer vectorized operations over explicit loops</li> <li>Document the mathematical basis for numerical algorithms in docstrings</li> <li>Include references to relevant literature for implemented methods</li> <li>Validate numerical stability and convergence properties</li> <li>Provide performance characteristics (computational complexity) for expensive operations</li> </ul>"},{"location":"api/core/#documentation-conventions","title":"Documentation Conventions","text":"<p>When adding new functions or methods, docstrings must follow MkDocs-compatible format for proper API documentation generation:</p>"},{"location":"api/core/#function-docstring-format","title":"Function Docstring Format","text":"<pre><code>def example_function(param1, param2=None):\n    \"\"\"Brief description of the function.\n\n    Detailed description of what the function does, including any important\n    implementation details or usage notes.\n\n    Args:\n        param1 (type): Description of param1.\n        param2 (type, optional): Description of param2. Defaults to None.\n\n    Returns:\n        type: Description of return value.\n\n    Raises:\n        ValueError: If param1 is invalid.\n        RuntimeError: If computation fails.\n\n    Example:\n        ```python\n        result = example_function(\"test\", param2=42)\n        print(result)\n        ```\n\n    Note:\n        Any additional notes about usage, performance, or limitations.\n    \"\"\"\n</code></pre>"},{"location":"api/core/#class-docstring-format","title":"Class Docstring Format","text":"<pre><code>class ExampleClass:\n    \"\"\"Brief description of the class.\n\n    Detailed description of the class purpose and functionality.\n\n    Attributes:\n        attr1 (type): Description of attribute.\n        attr2 (type): Description of attribute.\n\n    Example:\n        ```python\n        obj = ExampleClass()\n        obj.method_name()\n        ```\n    \"\"\"\n</code></pre>"},{"location":"api/core/#key-mkdocs-requirements","title":"Key MkDocs Requirements","text":"<ul> <li>Use triple quotes for all docstrings</li> <li>Include Args, Returns, and Raises sections where applicable</li> <li>Use type hints in parentheses: <code>param (torch.Tensor):</code></li> <li>Provide code examples in fenced code blocks with <code>python</code> language tag</li> <li>Keep first line brief and follow with detailed description</li> <li>Use proper Markdown formatting within docstrings</li> </ul>"},{"location":"api/core/#configuration-parameters","title":"Configuration Parameters","text":"<p>The general behavior of pyPFC is controlled by a set of configuration parameters, collected in a Python dictionary. The parameters are described in the table below.</p> Parameter name Defaults to Description alat 1.0 Lattice parameter (non-dimensional) alpha [1, 1] Gaussian peak widths in the pair correlation function \\(C_2\\), excluding the zero-mode peak C20_amplitude 0.0 Amplitude of the zero-mode Gaussian peak in \\(C_2\\) C20_alpha 1.0 Width of the zero-mode Gaussian peak in \\(C_2\\) density_interp_order 2 Interpolation order for density maxima localization density_merge_distance 0.1 Distance for merging density maxima (in units of lattice parameters) density_threshold 0.5 Threshold for density maxima detection device_number 0 GPU device number (if multiple GPUs are available) device_type 'gpu' PyTorch device ('cpu' or 'gpu') dtime 1.0e-3 Non-dimensional time increment \\(\\Delta\\tau\\) dtype_cpu np.double Floating-point precision of numpy arrays dtype_gpu torch.float64 Floating-point precision of PyTorch tensors evaluate_phase_field True Evaluate phase field (or not) normalize_pf True Normalize the phase fields to [0,1], or not npeaks 2 Number of Gaussian peaks, excluding the zero-mode peak, to use in \\(C_2\\) pf_gauss_var 0.1 Variance of the Gaussian smoothing kernel used in phase field evaluations pf_iso_level 0.5 Iso-level for phase field contouring sigma 0.0 Temperature-like parameter (non-dimensional) struct 'FCC' Crystal structure torch_threads 8 Number of CPU threads to use if device_type is 'cpu' torch_threads_interop 8 Number of interop threads to use if device_type is 'cpu' update_scheme '1st_order' Time integration scheme ('1st_order', '2nd_order' or 'exponential') update_scheme_params [1.0, 1.0, 1.0, None, None, None] Parameters in the time integration scheme: \\([g_1, g_2, g_3, \\alpha, \\beta, \\gamma]\\) verbose True Verbose output (or not)"},{"location":"api/core/#pypfc-architecture-overview","title":"pyPFC Architecture Overview","text":"<p>The pyPFC framework follows a strict inheritance hierarchy designed for modularity and extensibility:</p> <pre><code>graph TD\n    A[pypfc_grid] --&gt; B[pypfc_base]\n    B --&gt; C[pypfc_pre]\n    C --&gt; D[pypfc_io]\n    D --&gt; E[PyPFC]\n\n    A -.-&gt; F[**Grid Management**&lt;br/&gt;\u2022 Domain discretization&lt;br/&gt;]\n    B -.-&gt; G[**Core Operations**&lt;br/&gt;\u2022 Device management&lt;br/&gt;\u2022 FFT operations&lt;br/&gt;\u2022 Auxiliary functions]\n    C -.-&gt; H[**Pre-processing**&lt;br/&gt;\u2022 Density field generation&lt;br/&gt;\u2022 Structure initialization&lt;br/&gt;]\n    D -.-&gt; I[**Input/Output**&lt;br/&gt;\u2022 VTK export&lt;br/&gt;\u2022 Extended XYZ I/O&lt;br/&gt;\u2022 Binary pickle file I/O&lt;br/&gt;\u2022 ASCII text file I/O]\n    E -.-&gt; J[**Main Interface**&lt;br/&gt;\u2022 Simulation control&lt;br/&gt;\u2022 Time integration&lt;br/&gt;\u2022 Energy evaluation]</code></pre>"},{"location":"api/core/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/core/#memory-usage","title":"Memory Usage","text":"<p>Note that the numbers below are only indicative. Adding additional field, such as extra phase fields, will significantly increase memory usage.</p> Grid Size Double Precision Single Precision 256\u00b3 ~2 GB ~1 GB 512\u00b3 ~14 GB ~7 GB 768\u00b3 ~45 GB ~23 GB"},{"location":"api/core/#optimization-tips","title":"Optimization Tips","text":"<pre><code># For maximum performance\nparams_fast = {\n    'device_type': 'GPU',       # Run on GPU\n    'dtype_cpu':  np.single,    # Floating point precision, CPU\n    'dtype_gpu': torch.float32, # Floating point precision, GPU\n    'density_interp_order': 1,  # Reduced interpolation accuracy\n}\n\n# For maximum accuracy\nparams_precise = {\n    'device_type': 'GPU',       # Run on GPU \n    'dtype_cpu': np.double,     # Floating point precision, GPU\n    'dtype_gpu': torch.float64, # Floating point precision, GPU\n    'density_interp_order': 3,  # Better interpolation accuracy\n}\n</code></pre>"},{"location":"api/core/#usage-examples","title":"Usage Examples","text":"<p>Usage examples can be found on the Examples pages.</p>"},{"location":"api/pypfc/","title":"Class pypfc","text":"<p>               Bases: <code>setup_io</code></p> <p>This is the primary class for conducting PFC simulations, providing complete functionality for time evolution, energy evaluation, and phase field analysis. It combines all inherited capabilities from the class hierarchy:</p> <ul> <li>Grid setup and domain discretization (pypfc_grid)</li> <li>Mathematical operations and device management (pypfc_base)  </li> <li>Density field generation and crystal structures (pypfc_pre)</li> <li>File I/O operations and data export (pypfc_io)</li> </ul> <p>The class uses a configuration-driven approach where all simulation parameters are managed through a DEFAULTS dictionary. User configurations merge with defaults, to provide parameter handling with fallback values.</p> Notes <p>All grid divisions (ndiv) must be even numbers for FFT compatibility. The class automatically validates configuration parameters and provides informative error messages for invalid inputs.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation-functions","title":"Functions","text":""},{"location":"api/pypfc/#src.pypfc.setup_simulation.__init__","title":"__init__","text":"<pre><code>__init__(\n    domain_size: Union[List[float], ndarray],\n    ndiv: Optional[Union[List[int], ndarray]] = None,\n    config: Optional[Dict[str, Any]] = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize PFC simulation with domain parameters and configuration.</p> <p>Sets up the complete simulation environment including grid discretization, device configuration, and all numerical parameters needed for PFC evolution.</p> <p>Parameters:</p> Name Type Description Default <code>domain_size</code> <code>array_like of float, shape (3,)</code> <p>Physical size of simulation domain [Lx, Ly, Lz] in lattice parameter units. This defines the spatial extent of the simulation box.</p> required <code>ndiv</code> <code>array_like of int, shape (3,)</code> <p>Number of grid divisions [nx, ny, nz]. All values must be even numbers for FFT compatibility. If not provided, automatically calculated as <code>domain_size / alat * 8</code> (8 points per lattice spacing).</p> <code>None</code> <code>config</code> <code>dict</code> <p>Configuration parameters as key-value pairs. See the pyPFC overview for a complete list of the configuration parameters.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Individual configuration parameters passed as keyword arguments. These will override any corresponding values in the config dictionary.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any element in <code>ndiv</code> is not an even number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Basic simulation setup\n&gt;&gt;&gt; sim = setup_simulation([10.0, 10.0, 10.0])\n</code></pre> <pre><code>&gt;&gt;&gt; # Custom grid and parameters using config dictionary\n&gt;&gt;&gt; config = {'dtime': 5e-5, 'struct': 'BCC', 'verbose': True}\n&gt;&gt;&gt; sim = setup_simulation([8.0, 8.0, 8.0], ndiv=[64, 64, 64], config=config)\n</code></pre> <pre><code>&gt;&gt;&gt; # Using individual keyword arguments\n&gt;&gt;&gt; sim = setup_simulation([8.0, 8.0, 8.0], pf_iso_level=0.5, dtime=1e-4, verbose=True)\n</code></pre> <pre><code>&gt;&gt;&gt; # Mixing config dictionary and keyword arguments (kwargs take precedence)\n&gt;&gt;&gt; sim = setup_simulation([8.0, 8.0, 8.0], config=config, pf_iso_level=0.3)\n</code></pre>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.cleanup","title":"cleanup","text":"<pre><code>cleanup() -&gt; None\n</code></pre> <p>Clean up allocated tensors and free device memory.</p> <p>Explicitly deletes PyTorch tensors to free GPU/CPU memory. This is particularly important for GPU simulations to prevent memory leaks and ensure proper resource management.</p> Notes <p>This method should be called at the end of simulations, especially when running multiple simulations sequentially or when GPU memory is limited. The method automatically detects which tensors exist based on the update scheme and cleans up accordingly.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.do_step_update","title":"do_step_update","text":"<pre><code>do_step_update() -&gt; None\n</code></pre> <p>Update the PFC density field using the selected time integration scheme.</p> <p>Performs one time step of the PFC evolution equation using the time integration method specified by <code>_update_scheme</code>. The method operates in Fourier space for computational efficiency and automatically handles the FFT/iFFT transformations.</p> <p>Returns:</p> Name Type Description <code>f_den_d</code> <code>Tensor</code> <p>Updated density field in Fourier space. The real-space density field is automatically updated in <code>self._den_d</code> via inverse FFT.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified update_scheme is not supported.</p> Notes <p>This method uses precomputed linear terms for efficiency. The appropriate update method is selected based on <code>self._update_scheme</code> and called with the corresponding precomputed Fourier-space operators.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.evaluate_energy","title":"evaluate_energy","text":"<pre><code>evaluate_energy() -&gt; float\n</code></pre> <p>Evaluate the PFC energy.</p> <p>Computes the total free energy of the system using the phase field crystal energy functional.</p> <p>Returns:</p> Name Type Description <code>ene</code> <code>Tensor</code> <p>Energy field with shape [nx, ny, nz].</p> <code>eneAv</code> <code>float</code> <p>Average free energy density.</p> Notes <p>Energy is computed in Fourier space for efficiency and transformed back to real space for local energy density visualization.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.get_C2_d","title":"get_C2_d","text":"<pre><code>get_C2_d() -&gt; torch.Tensor\n</code></pre> <p>Get the current two-point correlation function.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>Two-point correlation function in Fourier space.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.get_alat","title":"get_alat","text":"<pre><code>get_alat() -&gt; float\n</code></pre> <p>Get the current lattice parameter.</p> <p>Returns:</p> Type Description <code>float</code> <p>Current lattice parameter value.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.get_alpha","title":"get_alpha","text":"<pre><code>get_alpha() -&gt; np.ndarray\n</code></pre> <p>Get the current alpha parameters.</p> <p>Returns:</p> Type Description <code>float</code> <p>Current alpha parameter values.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.get_density","title":"get_density","text":"<pre><code>get_density() -&gt; np.ndarray\n</code></pre> <p>Get the PFC density field and its mean value.</p> <p>Returns the current density field and its spatial average, transferring data from GPU to CPU if necessary.</p> <p>Returns:</p> Name Type Description <code>den</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field on CPU.</p> <code>mean_den</code> <code>float</code> <p>Spatially averaged density.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.get_dtime","title":"get_dtime","text":"<pre><code>get_dtime() -&gt; float\n</code></pre> <p>Get the current time step size.</p> <p>Returns:</p> Type Description <code>float</code> <p>Current time step size for integration.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.get_energy","title":"get_energy","text":"<pre><code>get_energy() -&gt; np.ndarray\n</code></pre> <p>Get the PFC energy field and its mean value.</p> <p>Computes the local energy density field and its spatial average using the current density field configuration.</p> <p>Returns:</p> Name Type Description <code>ene</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Local energy density field on CPU.</p> <code>mean_ene</code> <code>float</code> <p>Spatially averaged energy density.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.get_phase_field","title":"get_phase_field","text":"<pre><code>get_phase_field() -&gt; Union[np.ndarray, List[np.ndarray]]\n</code></pre> <p>Evaluate phase field using wavelet filtering.</p> <p>Computes the phase field by applying wavelet convolution followed by Gaussian smoothing. The phase field identifies crystalline regions and their orientations within the PFC density field.</p> <p>Returns:</p> Name Type Description <code>pf</code> <code>ndarray of float, shape (nx,ny,nz) or list of such arrays</code> <p>Phase field(s) on CPU. Returns a single array for isotropic kernels or a list of arrays for directional analysis with multiple kernels.</p> Notes <p>The method automatically handles both single and multiple wavelet kernels for comprehensive grain orientation analysis.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.get_update_scheme","title":"get_update_scheme","text":"<pre><code>get_update_scheme() -&gt; str\n</code></pre> <p>Establish the PFC time integration scheme and return method handle.</p> <p>Configures the selected time integration scheme and returns a function handle to the appropriate update method. This method sets up scheme-specific parameters and precomputed terms for efficient time stepping.</p> <p>Returns:</p> Name Type Description <code>update_density</code> <code>callable</code> <p>Function handle to the selected time integration method.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If alpha, beta, gamma parameters are not provided for '2nd_order' scheme.</p> <code>ValueError</code> <p>If f_denOld_d is not provided for '2nd_order' scheme.</p> <code>ValueError</code> <p>If the specified update_scheme is not supported.</p> Notes <p>The method automatically precomputes linear terms in Fourier space to optimize performance during time stepping. Different schemes require different numbers of precomputed terms and have varying stability properties and computational costs.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.get_update_scheme_params","title":"get_update_scheme_params","text":"<pre><code>get_update_scheme_params() -&gt; np.ndarray\n</code></pre> <p>Get the current integration scheme parameters.</p> <p>Returns:</p> Type Description <code>array_like</code> <p>Current parameters for the time integration scheme.</p>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_C2_d","title":"set_C2_d","text":"<pre><code>set_C2_d(C2_d: Tensor) -&gt; None\n</code></pre> <p>Set the two-point correlation function in Fourier space.</p> <p>Parameters:</p> Name Type Description Default <code>C2_d</code> <code>Tensor</code> <p>Two-point correlation function tensor in Fourier space. Must match the grid dimensions and be on the correct device.</p> required"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_H2","title":"set_H2","text":"<pre><code>set_H2(H0: float, Rot: ndarray) -&gt; None\n</code></pre> <p>Set the directional correlation kernel for extended PFC models.</p> <p>Configures the H2 kernel used in extended phase field crystal models to introduce directional correlations.</p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>float</code> <p>Amplitude of the directional correlation kernel.</p> required <code>Rot</code> <code>array_like or None</code> <p>Rotation matrix for orienting the kernel. If None, uses identity orientation.</p> required"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_alat","title":"set_alat","text":"<pre><code>set_alat(alat: float) -&gt; None\n</code></pre> <p>Set the lattice parameter.</p> <p>Parameters:</p> Name Type Description Default <code>alat</code> <code>float</code> <p>Lattice parameter.</p> required"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_alpha","title":"set_alpha","text":"<pre><code>set_alpha(alpha: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the alpha parameters, controlling the widths of the Gaussian peaks of the pair correlation function.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Pair correlation peak widths.</p> required"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_density","title":"set_density","text":"<pre><code>set_density(density: ndarray) -&gt; None\n</code></pre> <p>Set the PFC density field.</p> <p>Updates the density field and automatically computes its Fourier transform for subsequent calculations.</p> <p>Parameters:</p> Name Type Description Default <code>density</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>New density field configuration.</p> required"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_dtime","title":"set_dtime","text":"<pre><code>set_dtime(dtime: float) -&gt; None\n</code></pre> <p>Set the time step.</p> <p>Parameters:</p> Name Type Description Default <code>dtime</code> <code>float</code> <p>Time step size. Must be positive and small enough for stability.</p> required"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_phase_field_kernel","title":"set_phase_field_kernel","text":"<pre><code>set_phase_field_kernel(\n    H0: float = 1.0,\n    Rot: Optional[Union[ndarray, List[ndarray]]] = None,\n) -&gt; None\n</code></pre> <p>Set phase field kernel for directional analysis.</p> <p>Configures the correlation kernel used for phase field evaluation, allowing for directional filtering or isotropic analysis.</p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>float</code> <p>Kernel amplitude.</p> <code>1.0</code> <code>Rot</code> <code>ndarray of float, shape (3,3)</code> <p>Rotation matrix for directional kernel. If <code>None</code>, uses isotropic two-point correlation function.</p> <code>None</code>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_phase_field_smoothing_kernel","title":"set_phase_field_smoothing_kernel","text":"<pre><code>set_phase_field_smoothing_kernel(\n    pf_gauss_var: Optional[float] = None,\n) -&gt; None\n</code></pre> <p>Set phase field smoothing kernel.</p> <p>Configures Gaussian smoothing parameters for phase field calculations.</p> <p>Parameters:</p> Name Type Description Default <code>pf_gauss_var</code> <code>float</code> <p>Gaussian variance for smoothing kernel. If <code>None</code>, uses current value.</p> <code>None</code>"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_update_scheme","title":"set_update_scheme","text":"<pre><code>set_update_scheme(update_scheme: str) -&gt; None\n</code></pre> <p>Set the time integration scheme for density evolution.</p> <p>Parameters:</p> Name Type Description Default <code>update_scheme</code> <code>str</code> <p>Time integration method. Options: '1st_order', '2nd_order',  'exponential'.</p> required"},{"location":"api/pypfc/#src.pypfc.setup_simulation.set_update_scheme_params","title":"set_update_scheme_params","text":"<pre><code>set_update_scheme_params(\n    params: Union[List[float], ndarray],\n) -&gt; None\n</code></pre> <p>Set parameters for the time integration scheme.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>array_like</code> <p>Parameters specific to the chosen integration scheme. Format depends on the selected scheme type.</p> required"},{"location":"api/pypfc_base/","title":"Class pypfc_base","text":"<p>               Bases: <code>setup_grid</code></p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base-functions","title":"Functions","text":""},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.__init__","title":"__init__","text":"<pre><code>__init__(\n    domain_size: ndarray,\n    ndiv: ndarray,\n    config: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Initialize the base PFC setup with domain parameters and device configuration.</p> <p>Parameters:</p> Name Type Description Default <code>domain_size</code> <code>ndarray of float, shape (3,)</code> <p>Physical size of the simulation domain [Lx, Ly, Lz] in lattice parameter units.</p> required <code>ndiv</code> <code>ndarray of int, shape (3,)</code> <p>Number of grid divisions [nx, ny, nz]. Must be even numbers for FFT compatibility.</p> required <code>config</code> <code>dict</code> <p>Configuration parameters as key-value pairs. See the pyPFC overview for a complete list of the configuration parameters.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If dtype_gpu is not torch.float32 or torch.float64.</p> <code>ValueError</code> <p>If GPU is requested but no GPU is available.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.evaluate_C2_d","title":"evaluate_C2_d","text":"<pre><code>evaluate_C2_d() -&gt; torch.Tensor\n</code></pre> <p>Establish the two-point correlation function for a crystal structure.</p> <p>Computes the two-point pair correlation function in Fourier space for the specified crystal structure using Gaussian peaks at  reciprocal lattice positions.</p> <p>Returns:</p> Name Type Description <code>C2_d</code> <code>(Tensor, shape(nx, ny, nz // 2 + 1))</code> <p>Two-point pair correlation function on the computational device.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If C20_alpha is negative when C20_amplitude is non-zero.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.evaluate_directional_correlation_kernel","title":"evaluate_directional_correlation_kernel","text":"<pre><code>evaluate_directional_correlation_kernel(\n    H0: ndarray, Rot: ndarray\n) -&gt; torch.Tensor\n</code></pre> <p>Establish directional correlation kernel for a crystal structure.</p> <p>Computes directional correlation kernels used in extended PFC models to introduce orientational dependence.</p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>float</code> <p>Constant modulation of the peak height.</p> required <code>Rot</code> <code>ndarray of float, shape (3, 3) or None</code> <p>Lattice rotation matrix. If None, uses identity matrix.</p> required <p>Returns:</p> Name Type Description <code>H_d</code> <code>(Tensor, shape(nx, ny, nz // 2 + 1))</code> <p>Directional correlation kernel on the computational device.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.evaluate_k2_d","title":"evaluate_k2_d","text":"<pre><code>evaluate_k2_d() -&gt; torch.Tensor\n</code></pre> <p>Evaluate the sum of squared wave vectors for FFT operations.</p> <p>Computes \\(k^2 = k_x^2 + k_y^2 + k_z^2\\) on the computational device using PyTorch FFT frequency grids. This is fundamental for Fourier-space operations in PFC simulations.</p> <p>Returns:</p> Name Type Description <code>k2_d</code> <code>(Tensor, shape(nx, ny, nz_half))</code> <p>Sum of squared wave vectors on the device. The z-dimension is  reduced due to real FFT symmetry (nz_half = nz//2 + 1).</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.evaluate_reciprocal_planes","title":"evaluate_reciprocal_planes","text":"<pre><code>evaluate_reciprocal_planes() -&gt; torch.Tensor\n</code></pre> <p>Establish reciprocal vectors/planes for a crystal structure.</p> <p>Computes reciprocal lattice plane spacing (d-spacing) and wave vectors for crystallographic planes. For cubic systems: d = a / sqrt(h\u00b2 + k\u00b2 + l\u00b2) where a is the lattice parameter, and reciprocal spacing is k = 2\u03c0/d.</p> <p>Returns:</p> Name Type Description <code>k_plane</code> <code>ndarray of float</code> <p>Reciprocal lattice plane spacings (wave vector magnitudes).</p> <code>n_plane</code> <code>ndarray of int</code> <p>Number of symmetrical planes in each family.</p> <code>den_plane</code> <code>ndarray of float</code> <p>Atomic density within each plane family.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the crystal structure is not supported.</p> <code>ValueError</code> <p>If there are not enough peaks defined for the requested number of peaks.</p> Notes <p>For any family of lattice planes separated by distance d, there are reciprocal lattice points at intervals of 2\u03c0/d in reciprocal space.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_alpha","title":"get_alpha","text":"<pre><code>get_alpha() -&gt; np.ndarray\n</code></pre> <p>Get the Gaussian peak widths for the two-point correlation function.</p> <p>Returns:</p> Name Type Description <code>alpha</code> <code>ndarray of float</code> <p>Gaussian peak widths (\u03b1_i) for each peak in the correlation function.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_csp","title":"get_csp","text":"<pre><code>get_csp(\n    pos: ndarray, normalize_csp: bool = False\n) -&gt; np.ndarray\n</code></pre> <p>Calculate the centro-symmetry parameter (CSP) for atoms.</p> <p>Computes CSP values for atoms in a 3D periodic domain to identify crystal defects and disorder. CSP quantifies deviation from centro-symmetric local environments.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray of float, shape (natoms, 3)</code> <p>3D coordinates of atoms.</p> required <code>normalize_csp</code> <code>bool</code> <p>If True, normalizes CSP values to range [0,1].</p> <code>False</code> <p>Returns:</p> Name Type Description <code>csp</code> <code>ndarray of float, shape (natoms,)</code> <p>Centro-symmetry parameter for each atom.</p> References <p>C.L. Kelchner, S.J. Plimpton and J.C. Hamilton, Dislocation nucleation and defect structure during surface indentation, Phys. Rev. B, 58(17):11085-11088, 1998. https://doi.org/10.1103/PhysRevB.58.11085</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_device_number","title":"get_device_number","text":"<pre><code>get_device_number() -&gt; int\n</code></pre> <p>Get the current GPU device number.</p> <p>Returns:</p> Type Description <code>int</code> <p>Current GPU device index.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_device_type","title":"get_device_type","text":"<pre><code>get_device_type() -&gt; str\n</code></pre> <p>Get the current computation device type.</p> <p>Returns:</p> Type Description <code>str</code> <p>Current device type ('CPU' or 'GPU').</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_dtype_cpu","title":"get_dtype_cpu","text":"<pre><code>get_dtype_cpu() -&gt; type\n</code></pre> <p>Get the current CPU data type.</p> <p>Returns:</p> Type Description <code>dtype</code> <p>Current NumPy data type used for CPU arrays.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_dtype_gpu","title":"get_dtype_gpu","text":"<pre><code>get_dtype_gpu() -&gt; torch.dtype\n</code></pre> <p>Get the current GPU data type.</p> <p>Returns:</p> Type Description <code>dtype</code> <p>Current PyTorch data type used for GPU tensors.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_field_average_along_axis","title":"get_field_average_along_axis","text":"<pre><code>get_field_average_along_axis(\n    field: ndarray, axis: int\n) -&gt; np.ndarray\n</code></pre> <p>Evaluate the mean value of a field variable along a specified axis.</p> <p>Computes the spatial average of a 3D field along one axis,  reducing the dimensionality by averaging over the other two axes.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>ndarray of float, shape (nx, ny, nz)</code> <p>3D field variable to be averaged.</p> required <code>axis</code> <code>str</code> <p>Axis to average along: x, y or z (case insensitive).</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>ndarray of float</code> <p>1D array containing mean values along the specified axis. Shape depends on the axis: (nx,), (ny,), or (nz,).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If axis is not x, y or z.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_integrated_field_along_axis","title":"get_integrated_field_along_axis","text":"<pre><code>get_integrated_field_along_axis(\n    field: ndarray, axis: int\n) -&gt; np.ndarray\n</code></pre> <p>Integrate a field variable along a specified axis.</p> <p>Performs numerical integration of a 3D field variable along one axis, integrating over the two orthogonal directions.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>ndarray of float, shape (nx, ny, nz)</code> <p>3D field variable to be integrated.</p> required <code>axis</code> <code>str</code> <p>Axis to integrate along: x, y or z (case insensitive).</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>ndarray of float</code> <p>1D array containing integrated values along the specified axis. Shape depends on the axis: (nx,), (ny,), or (nz,).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If axis is not x, y or z.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_integrated_field_in_volume","title":"get_integrated_field_in_volume","text":"<pre><code>get_integrated_field_in_volume(\n    field: ndarray, limits: Union[List[float], ndarray]\n) -&gt; float\n</code></pre> <p>Integrate a field variable within a defined volume.</p> <p>Performs numerical integration of a field variable over a specified 3D volume on a Cartesian grid.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>ndarray of float, shape (nx, ny, nz)</code> <p>Field to be integrated over the specified volume.</p> required <code>limits</code> <code>array_like of float, length 6</code> <p>Spatial integration limits: [xmin, xmax, ymin, ymax, zmin, zmax].</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>float</code> <p>Result of the volume integration.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_k","title":"get_k","text":"<pre><code>get_k(npoints: int, dspacing: float) -&gt; np.ndarray\n</code></pre> <p>Define a 1D wave vector for Fourier space operations.</p> <p>Parameters:</p> Name Type Description Default <code>npoints</code> <code>int</code> <p>Number of grid points. Must be even.</p> required <code>dspacing</code> <code>float</code> <p>Grid spacing in real space.</p> required <p>Returns:</p> Name Type Description <code>k</code> <code>ndarray of float</code> <p>1D wave vector array with proper frequency ordering for FFTs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If npoints is not an even number.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_k2_d","title":"get_k2_d","text":"<pre><code>get_k2_d() -&gt; torch.Tensor\n</code></pre> <p>Get the wave vector magnitude squared tensor.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>Wave vector magnitude squared (k\u00b2) tensor in Fourier space.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_phase_field_contour","title":"get_phase_field_contour","text":"<pre><code>get_phase_field_contour(\n    pf: Union[ndarray, Tensor],\n    pf_zoom: float = 1.0,\n    evaluate_volume: bool = True,\n) -&gt; Union[Tuple[np.ndarray, float], np.ndarray]\n</code></pre> <p>Find the iso-contour surface of a 3D phase field using marching cubes.</p> <p>Extracts iso-surfaces from 3D phase field data using the marching cubes algorithm, with optional volume calculation for enclosed regions.</p> <p>Parameters:</p> Name Type Description Default <code>pf</code> <code>ndarray of float, shape (nx, ny, nz)</code> <p>3D phase field data for iso-surface extraction.</p> required <code>pf_zoom</code> <code>float</code> <p>Zoom factor for spatial coarsening/refinement.</p> <code>1.0</code> <code>evaluate_volume</code> <code>bool</code> <p>If True, calculates the volume enclosed by the iso-surface.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>verts</code> <code>ndarray of float, shape (n_vertices, 3)</code> <p>Vertices of the iso-surface triangulation.</p> <code>faces</code> <code>ndarray of int, shape (n_faces, 3)</code> <p>Surface triangulation topology (vertex indices).</p> <code>volume</code> <code>(float, optional)</code> <p>Volume enclosed by the iso-surface (only if evaluate_volume=True).</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_rlv","title":"get_rlv","text":"<pre><code>get_rlv(struct: str, alat: float) -&gt; np.ndarray\n</code></pre> <p>Get the reciprocal lattice vectors for a crystal structure.</p> <p>Computes reciprocal lattice vectors for common crystal structures used in phase field crystal modeling.</p> <p>Parameters:</p> Name Type Description Default <code>struct</code> <code>str</code> <p>Crystal structure type. Options: 'SC', 'BCC', 'FCC', 'DC'.</p> required <code>alat</code> <code>float</code> <p>Lattice parameter.</p> required <p>Returns:</p> Name Type Description <code>rlv</code> <code>ndarray of float, shape (nrlv, 3)</code> <p>Reciprocal lattice vectors for the specified crystal structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the crystal structure is not supported.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_time_stamp","title":"get_time_stamp","text":"<pre><code>get_time_stamp() -&gt; str\n</code></pre> <p>Get current timestamp string.</p> <p>Returns:</p> Name Type Description <code>timestamp</code> <code>str</code> <p>Current date and time in format: YYYY-MM-DD HH:MM.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_torch_threads","title":"get_torch_threads","text":"<pre><code>get_torch_threads() -&gt; Tuple[int, int]\n</code></pre> <p>Get the current PyTorch thread configuration.</p> <p>Returns:</p> Type Description <code>tuple of int</code> <p>(num_threads, num_interop_threads) for PyTorch operations.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_verbose","title":"get_verbose","text":"<pre><code>get_verbose() -&gt; bool\n</code></pre> <p>Get the current verbose output setting.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Current verbose mode setting.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.get_xtal_nearest_neighbors","title":"get_xtal_nearest_neighbors","text":"<pre><code>get_xtal_nearest_neighbors() -&gt; (\n    Tuple[np.ndarray, np.ndarray]\n)\n</code></pre> <p>Get nearest neighbor information for crystal structures.</p> <p>Computes nearest neighbor distances and coordination numbers for common crystal structures used in phase field crystal modeling.</p> <p>Returns:</p> Name Type Description <code>nnb</code> <code>ndarray of int</code> <p>Number of nearest and next-nearest neighbors.</p> <code>nnb_dist</code> <code>ndarray of float</code> <p>Distances to the nearest and next-nearest neighbors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the crystal structure is not supported.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.interpolate_atoms","title":"interpolate_atoms","text":"<pre><code>interpolate_atoms(\n    intrp_pos: ndarray,\n    pos: ndarray,\n    values: ndarray,\n    num_nnb: int = 8,\n    power: int = 2,\n) -&gt; np.ndarray\n</code></pre> <p>Interpolate values at given positions using inverse distance weighting.</p> <p>Performs 3D interpolation in a periodic domain using inverse distance weighting: interpolated_value = \u03a3(wi \u00d7 vi) / \u03a3(wi), where wi = 1 / (di^power).</p> <p>Parameters:</p> Name Type Description Default <code>intrp_pos</code> <code>ndarray of float, shape (n_intrp, 3)</code> <p>3D coordinates of positions where values should be interpolated.</p> required <code>pos</code> <code>ndarray of float, shape (n_particles, 3)</code> <p>3D coordinates of particles with known values.</p> required <code>values</code> <code>ndarray of float, shape (n_particles,)</code> <p>Values at the particle positions to be interpolated.</p> required <code>num_nnb</code> <code>int</code> <p>Number of nearest neighbors to use for interpolation.</p> <code>8</code> <code>power</code> <code>float</code> <p>Power for inverse distance weighting.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>interp_val</code> <code>ndarray of float, shape (n_intrp,)</code> <p>Interpolated values at the specified positions.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.interpolate_density_maxima","title":"interpolate_density_maxima","text":"<pre><code>interpolate_density_maxima(\n    den: Union[ndarray, Tensor],\n    ene: Optional[Union[ndarray, Tensor]] = None,\n    pf: Optional[Union[ndarray, Tensor]] = None,\n) -&gt; Tuple[\n    np.ndarray, Optional[np.ndarray], Optional[np.ndarray]\n]\n</code></pre> <p>Find density field maxima and interpolate atomic positions and properties.</p> <p>Identifies local maxima in the density field as atomic positions and performs high-order interpolation to obtain sub-grid precision coordinates. Also  interpolates associated field values (density, energy, phase fields) at the atomic positions.</p> <p>Parameters:</p> Name Type Description Default <code>den</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field from PFC simulation.</p> required <code>ene</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Energy field for interpolation at atomic positions.</p> <code>None</code> <code>pf</code> <code>list of ndarray</code> <p>List of phase fields for interpolation at atomic positions. Each array should have shape (nx,ny,nz).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>atom_coord</code> <code>ndarray of float, shape (n_maxima,3)</code> <p>Interpolated coordinates of density maxima (atomic positions).</p> <code>atom_data</code> <code>ndarray of float, shape (n_maxima, 2+n_phase_fields)</code> <p>Interpolated field values at atomic positions. Columns: [density, energy, pf1, pf2, ..., pfN]</p> Notes <p>The method uses scipy.ndimage for high-order interpolation and applies density thresholding and merging of nearby maxima to remove spurious peaks. The interpolation order is controlled by the <code>_density_interp_order</code> attribute.</p>"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.set_alpha","title":"set_alpha","text":"<pre><code>set_alpha(alpha: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the Gaussian peak widths for the two-point correlation function.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>array_like of float</code> <p>Gaussian peak widths (\u03b1_i) for each peak in the correlation function.</p> required"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.set_device_number","title":"set_device_number","text":"<pre><code>set_device_number(device_number: int) -&gt; None\n</code></pre> <p>Set the GPU device number for multi-GPU systems.</p> <p>Parameters:</p> Name Type Description Default <code>device_number</code> <code>int</code> <p>GPU device index (0, 1, 2, ...) for CUDA computations.</p> required"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.set_device_type","title":"set_device_type","text":"<pre><code>set_device_type(device_type: str) -&gt; None\n</code></pre> <p>Set the computation device type.</p> <p>Parameters:</p> Name Type Description Default <code>device_type</code> <code>str</code> <p>Device type for computations. Options: 'CPU', 'GPU'.</p> required"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.set_dtype_cpu","title":"set_dtype_cpu","text":"<pre><code>set_dtype_cpu(dtype: type) -&gt; None\n</code></pre> <p>Set the CPU data type for numpy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>dtype</code> <p>NumPy data type for CPU computations (e.g., np.float32, np.float64).</p> required"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.set_dtype_gpu","title":"set_dtype_gpu","text":"<pre><code>set_dtype_gpu(dtype: dtype) -&gt; None\n</code></pre> <p>Set the GPU data type for PyTorch tensors.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>dtype</code> <p>PyTorch data type for GPU computations (e.g., torch.float32, torch.float64).</p> required"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.set_k2_d","title":"set_k2_d","text":"<pre><code>set_k2_d(k2_d: Tensor) -&gt; None\n</code></pre> <p>Set the wave vector magnitude squared tensor.</p> <p>Parameters:</p> Name Type Description Default <code>k2_d</code> <code>Tensor</code> <p>Wave vector magnitude squared (k\u00b2) tensor in Fourier space. Used for FFT-based operations and differential operators.</p> required"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.set_torch_threads","title":"set_torch_threads","text":"<pre><code>set_torch_threads(\n    nthreads: int, nthreads_interop: int\n) -&gt; None\n</code></pre> <p>Set PyTorch thread configuration for CPU operations.</p> <p>Parameters:</p> Name Type Description Default <code>nthreads</code> <code>int</code> <p>Number of threads for intra-op parallelism.</p> required <code>nthreads_interop</code> <code>int</code> <p>Number of threads for inter-op parallelism.</p> required"},{"location":"api/pypfc_base/#src.pypfc_base.setup_base.set_verbose","title":"set_verbose","text":"<pre><code>set_verbose(verbose: bool) -&gt; None\n</code></pre> <p>Set verbose output mode for debugging and monitoring.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, enables detailed timing and progress output.</p> required"},{"location":"api/pypfc_grid/","title":"Class pypfc_grid","text":"<p>Provides the foundational grid management functionality for PFC simulations.</p>"},{"location":"api/pypfc_grid/#src.pypfc_grid.setup_grid-functions","title":"Functions","text":""},{"location":"api/pypfc_grid/#src.pypfc_grid.setup_grid.__init__","title":"__init__","text":"<pre><code>__init__(\n    domain_size: Union[List[float], ndarray],\n    ndiv: Union[List[int], ndarray],\n) -&gt; None\n</code></pre> <p>Initialize the grid setup with domain size and grid divisions.</p> <p>Parameters:</p> Name Type Description Default <code>domain_size</code> <code>ndarray of float, shape (3,)</code> <p>Physical size of the simulation domain in each direction [Lx, Ly, Lz]. Specified in lattice parameter units for crystal simulations.</p> required <code>ndiv</code> <code>ndarray of int, shape (3,)</code> <p>Number of grid divisions along each coordinate axis [nx, ny, nz]. All values must be even numbers for FFT compatibility.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any element in <code>ndiv</code> is not an even number.</p>"},{"location":"api/pypfc_grid/#src.pypfc_grid.setup_grid.copy_from","title":"copy_from","text":"<pre><code>copy_from(grid: setup_grid) -&gt; None\n</code></pre> <p>Copy grid parameters from another grid object.</p> <p>This method copies all grid configuration parameters from another  setup_grid instance, including domain size, grid divisions, and derived parameters.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>setup_grid</code> <p>Another setup_grid instance to copy parameters from.</p> required"},{"location":"api/pypfc_grid/#src.pypfc_grid.setup_grid.get_ddiv","title":"get_ddiv","text":"<pre><code>get_ddiv() -&gt; np.ndarray\n</code></pre> <p>Get the grid spacing in each direction.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Grid spacing [dx, dy, dz] for each coordinate axis.</p>"},{"location":"api/pypfc_grid/#src.pypfc_grid.setup_grid.get_domain_size","title":"get_domain_size","text":"<pre><code>get_domain_size() -&gt; np.ndarray\n</code></pre> <p>Get the physical domain size in each direction.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Physical domain size [Lx, Ly, Lz] in lattice parameters.</p>"},{"location":"api/pypfc_grid/#src.pypfc_grid.setup_grid.get_ndiv","title":"get_ndiv","text":"<pre><code>get_ndiv() -&gt; np.ndarray\n</code></pre> <p>Get the number of grid divisions in each direction.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Number of grid divisions [nx, ny, nz] along each axis.</p>"},{"location":"api/pypfc_grid/#src.pypfc_grid.setup_grid.set_ddiv","title":"set_ddiv","text":"<pre><code>set_ddiv(ddiv: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the grid spacing in each direction.</p> <p>Parameters:</p> Name Type Description Default <code>ddiv</code> <code>array_like of float, shape (3,)</code> <p>Grid spacing in each direction [dx, dy, dz].</p> required"},{"location":"api/pypfc_grid/#src.pypfc_grid.setup_grid.set_ndiv","title":"set_ndiv","text":"<pre><code>set_ndiv(ndiv: Union[List[int], ndarray]) -&gt; None\n</code></pre> <p>Set the number of grid divisions in each direction.</p> <p>Updates the grid division parameters and related grid point counts. All divisions must be even numbers for FFT compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>ndiv</code> <code>array_like of int, shape (3,)</code> <p>Number of grid divisions in each direction [nx, ny, nz].  Must be even numbers.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any value in ndiv is not an even number.</p>"},{"location":"api/pypfc_io/","title":"Class pypfc_io","text":"<p>               Bases: <code>setup_pre</code></p> <p>I/O operations for Phase Field Crystal simulation data.</p> <p>This class provides comprehensive file I/O functionality for PFC simulations including:</p> <ul> <li>Extended XYZ format for atomic positions and properties</li> <li>VTK output for visualization in ParaView/VisIt</li> <li>Binary pickle serialization for Python objects</li> <li>Structured grid data export for continuous fields</li> <li>Point data export for atomic/particle systems</li> <li>Simulation metadata and setup information files</li> </ul> <p>The class supports both text and binary formats, with optional compression for large datasets. All methods are designed to handle typical PFC simulation outputs including atomic positions, density fields, energy fields and phase field data.</p> Notes <p>The extended XYZ format follows the convention used in molecular dynamics and materials simulation communities, allowing storage of arbitrary per-atom properties alongside coordinates. VTK output enables direct visualization in scientific visualization software.</p>"},{"location":"api/pypfc_io/#src.pypfc_io.setup_io-functions","title":"Functions","text":""},{"location":"api/pypfc_io/#src.pypfc_io.setup_io.__init__","title":"__init__","text":"<pre><code>__init__(\n    domain_size: Union[List[float], ndarray],\n    ndiv: Union[List[int], ndarray],\n    config: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Initialize I/O handler with domain parameters and device configuration.</p> <p>Parameters:</p> Name Type Description Default <code>domain_size</code> <code>ndarray of float, shape (3,)</code> <p>Physical size of the simulation domain [Lx, Ly, Lz] in lattice parameter units.</p> required <code>ndiv</code> <code>ndarray of int, shape (3,)</code> <p>Number of grid divisions [nx, ny, nz]. Must be even numbers for FFT compatibility.</p> required <code>config</code> <code>dict</code> <p>Configuration parameters as key-value pairs. See the pyPFC overview for a complete list of the configuration parameters.</p> required"},{"location":"api/pypfc_io/#src.pypfc_io.setup_io.append_to_info_file","title":"append_to_info_file","text":"<pre><code>append_to_info_file(\n    info: Union[str, List[str]],\n    filename: str = \"pypfc_simulation.txt\",\n    output_path: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Append information to a text file.</p> <p>Adds new content to an existing text file, useful for logging simulation progress or adding additional information to setup files.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>str or list of str</code> <p>String or list of strings to append to the file.</p> required <code>filename</code> <code>str</code> <p>Name of the output file.</p> <code>'pypfc_simulation.txt'</code> <code>output_path</code> <code>str</code> <p>Path to the output directory. Uses the current working directory as default.</p> <code>None</code>"},{"location":"api/pypfc_io/#src.pypfc_io.setup_io.load_pickle","title":"load_pickle","text":"<pre><code>load_pickle(filename: str, ndata: int) -&gt; List[Any]\n</code></pre> <p>Load data objects from a binary pickle file.</p> <p>Deserializes Python objects from a pickle file created with <code>save_pickle</code>. Reads a specified number of objects from the binary file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to input pickle file (without .pickle extension).</p> required <code>ndata</code> <code>int</code> <p>Number of data objects to read from the file.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>list</code> <p>List of Python objects loaded from <code>filename.pickle</code>.</p> Warning <p>Only load pickle files from trusted sources, as they can execute arbitrary code during deserialization.</p>"},{"location":"api/pypfc_io/#src.pypfc_io.setup_io.read_extended_xyz","title":"read_extended_xyz","text":"<pre><code>read_extended_xyz(\n    filename: str, nfields: int = 0\n) -&gt; Tuple[\n    np.ndarray, List[float], float, List[np.ndarray]\n]\n</code></pre> <p>Read PFC data from extended XYZ format file.</p> <p>Reads atomic positions and associated properties from an extended XYZ file, which may be compressed with gzip. Automatically detects file format and handles both .xyz and .xyz.gz extensions.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of input XYZ file (with or without .xyz/.xyz.gz extension).</p> required <code>nfields</code> <code>int</code> <p>Number of data fields per atom beyond coordinates [x,y,z].</p> <code>0</code> <p>Returns:</p> Name Type Description <code>coord</code> <code>ndarray of float, shape (natoms, 3)</code> <p>Atomic coordinates.</p> <code>domain_size</code> <code>ndarray of float, shape (3,)</code> <p>Domain size [Lx, Ly, Lz] from file header.</p> <code>time</code> <code>float</code> <p>Simulation time from file header.</p> <code>partDen</code> <code>ndarray of float, shape (natoms,)</code> <p>Particle density values (if available).</p> <code>partEne</code> <code>ndarray of float, shape (natoms,)</code> <p>Particle energy values (if available).</p> <code>partPf</code> <code>ndarray of float, shape (natoms,)</code> <p>Particle phase field values (if available).</p>"},{"location":"api/pypfc_io/#src.pypfc_io.setup_io.save_pickle","title":"save_pickle","text":"<pre><code>save_pickle(filename: str, data: List[Any]) -&gt; None\n</code></pre> <p>Save data objects to a binary pickle file.</p> <p>Serializes a list of Python objects to a binary pickle file for efficient storage and later retrieval. This is useful for saving simulation state, configuration parameters or processed results.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the output file (without .pickle extension).</p> required <code>data</code> <code>list</code> <p>List of Python objects to serialize and save.</p> required Notes <p>The output file will be named <code>filename.pickle</code>. Pickle files are Python-specific binary format that preserves object structure and types.</p> Warning <p>Only load pickle files from trusted sources, as they can execute arbitrary code during deserialization.</p>"},{"location":"api/pypfc_io/#src.pypfc_io.setup_io.write_extended_xyz","title":"write_extended_xyz","text":"<pre><code>write_extended_xyz(\n    filename: str,\n    coord: ndarray,\n    atom_data: List[ndarray],\n    atom_data_labels: List[str],\n    simulation_time: float = 0.0,\n    gz: bool = True,\n) -&gt; None\n</code></pre> <p>Save PFC atomic data in extended XYZ format.</p> <p>Writes atomic positions and associated properties to an extended XYZ file, which is a standard format in molecular dynamics and materials simulation. The format includes atomic coordinates plus arbitrary per-atom properties such as density, energy, phase field values, etc.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Base name of the output XYZ file (without extension).</p> required <code>coord</code> <code>ndarray of float, shape (natoms, 3)</code> <p>Atomic coordinates [x, y, z] for each atom.</p> required <code>atom_data</code> <code>list of ndarray</code> <p>List of arrays containing per-atom data. Each array must have shape (natoms,) and represent a property for each atom.</p> required <code>atom_data_labels</code> <code>list of str</code> <p>Labels for each data array in <code>atom_data</code>. Must have same length as <code>atom_data</code> list.</p> required <code>simulation_time</code> <code>float</code> <p>Simulation time to include in file header.</p> <code>0.0</code> <code>gz</code> <code>bool</code> <p>If <code>True</code>, compress output using gzip.</p> <code>True</code> Notes <p>The output file will be named <code>filename.xyz</code> or <code>filename.xyz.gz</code> if compression is enabled. The extended XYZ format includes a header with the number of atoms, simulation time, and property labels, followed by atomic coordinates and properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; write_extended_xyz('output', coord, [density, energy], \n...                   ['density', 'energy'], simulation_time=100.0)\n</code></pre>"},{"location":"api/pypfc_io/#src.pypfc_io.setup_io.write_info_file","title":"write_info_file","text":"<pre><code>write_info_file(\n    filename: str = \"pypfc_simulation.txt\",\n    output_path: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Write simulation setup information to a file.</p> <p>Creates a text file containing simulation parameters, grid configuration, and other setup information for documentation and reproducibility.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the output file.</p> <code>'pypfc_simulation.txt'</code> <code>output_path</code> <code>str</code> <p>Path to the output directory. Uses the current working directory as default.</p> <code>None</code>"},{"location":"api/pypfc_io/#src.pypfc_io.setup_io.write_vtk_points","title":"write_vtk_points","text":"<pre><code>write_vtk_points(\n    filename: str,\n    coord: ndarray,\n    scalar_data: List[ndarray],\n    scalar_data_name: List[str],\n    vector_data: Optional[List[ndarray]] = None,\n    vector_data_name: Optional[List[str]] = None,\n    tensor_data: Optional[List[ndarray]] = None,\n    tensor_data_name: Optional[List[str]] = None,\n) -&gt; None\n</code></pre> <p>Save 3D point data to VTK file for visualization.</p> <p>Exports atomic positions and associated scalar, vector and tensor data to a VTK (Visualization Toolkit) file in binary XML format. This format is compatible with ParaView, VisIt and other scientific visualization software.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output file name (with or without .vtu extension).</p> required <code>coord</code> <code>ndarray of float, shape (natoms, 3)</code> <p>3D coordinates of points/atoms.</p> required <code>scalar_data</code> <code>list of ndarray</code> <p>List of scalar data arrays. Each array should have shape (natoms,).</p> required <code>scalar_data_name</code> <code>list of str</code> <p>Names/labels for each scalar data array. Must match length of <code>scalarData</code>.</p> required <code>vector_data</code> <code>list of ndarray</code> <p>List of vector data arrays. Each array should have shape (natoms, 3).</p> <code>None</code> <code>vector_data_name</code> <code>list of str</code> <p>Names/labels for each vector data array. Required if <code>vectorData</code> is provided.</p> <code>None</code> <code>tensor_data</code> <code>list of ndarray</code> <p>List of tensor data arrays. Each array should have shape (natoms, 3, 3). Tensors are automatically reshaped to VTK format (natoms, 9).</p> <code>None</code> <code>tensor_data_name</code> <code>list of str</code> <p>Names/labels for each tensor data array. Required if <code>tensorData</code> is provided.</p> <code>None</code> Notes <p>Tensor data is reshaped from (3,3) matrices to 9-component vectors following VTK convention:</p> \\[T = \\begin{bmatrix}  T_{11} &amp; T_{12} &amp; T_{13} \\\\ T_{21} &amp; T_{22} &amp; T_{23} \\\\ T_{31} &amp; T_{32} &amp; T_{33}  \\end{bmatrix}\\] <p>becomes: \\([T_{11}, T_{12}, T_{13}, T_{21}, T_{22}, T_{23}, T_{31}, T_{32}, T_{33}]\\)</p>"},{"location":"api/pypfc_io/#src.pypfc_io.setup_io.write_vtk_structured_grid","title":"write_vtk_structured_grid","text":"<pre><code>write_vtk_structured_grid(\n    filename: str,\n    array_data: List[ndarray],\n    array_name: List[str],\n) -&gt; None\n</code></pre> <p>Save 3D field data to VTK structured grid file.</p> <p>Exports 3D field data (such as density, energy, or phase fields) to a  VTK structured grid file in binary XML format. This format is ideal for visualizing continuous field data in ParaView, VisIt and other  scientific visualization software.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output file name (with or without .vts extension).</p> required <code>array_data</code> <code>list of ndarray</code> <p>List of 3D numpy arrays containing field data. Each array should have shape (nx, ny, nz) matching the simulation grid.</p> required <code>array_name</code> <code>list of str</code> <p>Names/labels for each data array. Must match length of <code>arrayData</code>.</p> required Notes <p>The output file will be named <code>filename.vts</code> and uses VTK's structured grid format with binary encoding for efficient storage. The grid  dimensions and spacing are automatically determined from the inherited grid setup.</p>"},{"location":"api/pypfc_ovito/","title":"Class pypfc_ovito","text":"<p>This class provides custom interfaces to selected functionalities in OVITO, useful for post-processing of pyPFC simulation output and crystal structure analysis.</p> <p>The <code>ovito</code> Python package must be installed.</p> <p>               Bases: <code>setup_grid</code></p>"},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup-functions","title":"Functions","text":""},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup.__init__","title":"__init__","text":"<pre><code>__init__(\n    ndiv: Union[List[int], ndarray],\n    ddiv: Union[List[float], ndarray],\n    dtype_cpu: dtype = np.double,\n    struct: str = \"FCC\",\n    pos: Optional[ndarray] = None,\n    verbose: bool = False,\n) -&gt; None\n</code></pre> <p>Initialize the pypfc_ovito setup with domain size and grid divisions.</p> <p>Parameters:</p> Name Type Description Default <code>ndiv</code> <code>ndarray of int, shape (3,)</code> <p>Number of grid divisions along each coordinate axis [nx, ny, nz].</p> required <code>ddiv</code> <code>ndarray of float, shape (3,)</code> <p>Grid spacing along each coordinate axis [dx, dy, dz].</p> required <code>dtype_cpu</code> <code>dtype</code> <p>CPU data type for numerical arrays.</p> <code>double</code> <code>struct</code> <code>str</code> <p>Crystal structure type.</p> <ul> <li>'FCC': Face-centered cubic</li> <li>'BCC': Body-centered cubic</li> </ul> <code>'FCC'</code> <code>pos</code> <code>ndarray of float, shape (N,3)</code> <p>Initial atomic positions. If <code>None</code>, positions will be generated based on the crystal structure.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Enable verbose output for debugging and monitoring.</p> <code>False</code>"},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup.do_ovito_csp","title":"do_ovito_csp","text":"<pre><code>do_ovito_csp(num_neighbors: int = 12) -&gt; np.ndarray\n</code></pre> <p>Evaluate the Centro-Symmetry Parameter (CSP) for each atom using OVITO.</p> <p>The CSP value is a useful measure for identifying defects in crystal structures.  Lower values indicate more perfect crystal structure.</p> <p>Parameters:</p> Name Type Description Default <code>num_neighbors</code> <code>int</code> <p>Number of nearest neighbors to consider for CSP calculation.</p> <ul> <li>FCC structure: 12</li> <li>BCC structure: 8</li> </ul> <code>12</code> <p>Returns:</p> Name Type Description <code>csp_values</code> <code>(ndarray, shape(N))</code> <p>Array of CSP values for each atom.</p> References <p>A. Stukowski (2010), Visualization and analysis of atomistic simulation data with OVITO - the Open Visualization Tool, Modelling Simul. Mater. Sci. Eng. 18, 015012. https://doi.org/10.1088/0965-0393/18/1/015012</p> <p>C.L. Kelchner, S.J. Plimpton and J.C. Hamilton, Dislocation nucleation and defect structure during surface indentation, Phys. Rev. B, 58(17):11085-11088, 1998. https://doi.org/10.1103/PhysRevB.58.11085</p>"},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup.do_ovito_dxa","title":"do_ovito_dxa","text":"<pre><code>do_ovito_dxa(\n    rep: Union[List[int], ndarray] = [1, 1, 1],\n    tol: float = 1e-08,\n) -&gt; Tuple[\n    np.ndarray,\n    np.ndarray,\n    np.ndarray,\n    np.ndarray,\n    np.ndarray,\n    List[np.ndarray],\n]\n</code></pre> <p>Perform dislocation analysis using OVITO's Dislocation eXtraction Algorithm (DXA).</p> <p>Parameters:</p> Name Type Description Default <code>rep</code> <code>array_like of int, shape (3,)</code> <p>Number of simulation box replications to consider in the periodic directions:  [n_rep_x, n_rep_y, n_rep_z]. Default is no replication.</p> <code>[1, 1, 1]</code> <code>tol</code> <code>float</code> <p>Tolerance parameter for dislocation type identification.</p> <code>1e-08</code> <p>Returns:</p> Name Type Description <code>disl_type_ids</code> <code>ndarray of int, shape (N,)</code> <p>Array of dislocation type IDs:</p> <ul> <li>0: \\(\\langle 100\\rangle\\) Composite</li> <li>1: \\(\\frac{1}{2}\\langle 110\\rangle\\) Perfect edge</li> <li>2: \\(\\frac{1}{6}\\langle 112\\rangle\\) Shockley screw</li> <li>3: \\(\\frac{1}{6}\\langle 110\\rangle\\) Stair-rod</li> <li>4: \\(\\frac{1}{3}\\langle 100\\rangle\\) Hirth</li> <li>5: \\(\\frac{1}{3}\\langle 111\\rangle\\) Frank</li> <li>6: other</li> </ul> <code>disl_coord</code> <code>ndarray of float, shape (N,3)</code> <p>Coordinates of the first point of each dislocation line.</p> <code>disl_line_len</code> <code>ndarray of float, shape (N,)</code> <p>Array of dislocation line lengths.</p> <code>disl_line_dir</code> <code>ndarray of float, shape (N,3)</code> <p>Array of dislocation line direction unit vectors.</p> <code>disl_burg_vec</code> <code>ndarray of float, shape (N,3)</code> <p>Array of Burgers vectors.</p> <code>disl_segm_pts</code> <code>ndarray of int, shape (N,)</code> <p>List of dislocation segment points.</p> References <p>A. Stukowski, V.V. Bulatov and A. Arsenlis (2012), Automated identification and indexing of dislocations in crystal interfaces, Modelling Simul. Mater. Sci. Eng. 20, 085007. https://doi.org/10.1088/0965-0393/20/8/085007</p>"},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup.do_ovito_ptm","title":"do_ovito_ptm","text":"<pre><code>do_ovito_ptm(\n    ref_rot: Optional[ndarray] = None,\n    output_euler_ang: bool = False,\n    output_strain: bool = False,\n) -&gt; Union[\n    Tuple[np.ndarray, np.ndarray],\n    Tuple[np.ndarray, np.ndarray, np.ndarray],\n]\n</code></pre> <p>Evaluate crystal structure, crystallographic orientation and elastic strain tensor using OVITO's Polyhedral Template Matching (PTM) algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>ref_rot</code> <code>array_like of float, shape (3,3)</code> <p>Reference rotation matrix.</p> <code>None</code> <code>output_euler_ang</code> <code>bool</code> <p>Format of output orientation representation:</p> <ul> <li><code>True</code>: Euler angles (ZXZ convention).</li> <li><code>False</code>: Quaternions. This is the default.</li> </ul> <code>False</code> <code>output_strain</code> <code>bool</code> <p>Whether to evaluate the local elastic Green-Lagrange strain tensors:</p> <ul> <li><code>True</code>: Compute strain tensors for each atom.</li> <li><code>False</code>: Skip strain calculation.</li> </ul> <code>False</code> <p>Returns:</p> Name Type Description <code>structure_id</code> <code>ndarray of int, shape (N,)</code> <p>Integer array of structure types per atom:</p> <ul> <li>0: Other/Unknown</li> <li>1: FCC (face-centered cubic)</li> <li>2: HCP (hexagonal close-packed)</li> <li>3: BCC (body-centered cubic)</li> <li>4: ICO (icosahedral coordination)</li> <li>5: SC (simple cubic)</li> <li>6: Cubic diamond</li> <li>7: Hexagonal diamond</li> <li>8: Graphene</li> </ul> <code>rot</code> <code>ndarray of float, shape (N,3) or (N,4)</code> <p>Local crystal orientation expressed as Euler angles or quaternions,  saved per atom as \\([\\varphi_{1}, \\Psi, \\varphi_{2}]\\) or (if <code>output_euler_ang=True</code>).</p> <code>strain</code> <code>ndarray of float, shape (N,6)</code> <p>Local Green-Lagrange strain tensor (if <code>output_strain=True</code>),  saved per atom as \\([\\epsilon_{xx}, \\epsilon_{yy}, \\epsilon_{zz}, \\epsilon_{xy}, \\epsilon_{xz}, \\epsilon_{yz}]\\).</p> References <p>P.M. Larsen et al. (2016), Robust Structural Identification via Polyhedral Template Matching, Modelling Simul. Mater. Sci. Eng. 24, 055007. https://doi.org/10.1088/0965-0393/24/5/055007</p> <p>A. Stukowski (2010), Visualization and analysis of atomistic simulation data with OVITO - the Open Visualization Tool, Modelling Simul. Mater. Sci. Eng. 18, 015012. https://doi.org/10.1088/0965-0393/18/1/015012</p>"},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup.get_coord","title":"get_coord","text":"<pre><code>get_coord() -&gt; np.ndarray\n</code></pre> <p>Get atom coordinates.</p> <p>Returns:</p> Name Type Description <code>coord</code> <code>ndarray of float, shape (N,3)</code> <p>Atom (x, y, z) coordinates.</p>"},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup.get_struct","title":"get_struct","text":"<pre><code>get_struct() -&gt; str\n</code></pre> <p>Get crystal structure type.</p> <p>Returns:</p> Name Type Description <code>struct</code> <code>str</code> <p>Crystal structure type: <code>'FCC'</code>, <code>'BCC'</code>.</p>"},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup.set_coord","title":"set_coord","text":"<pre><code>set_coord(coord: ndarray) -&gt; None\n</code></pre> <p>Set atom coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coord</code> <code>ndarray of float, shape (N,3)</code> <p>Atom (x, y, z) coordinates.</p> required"},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup.set_struct","title":"set_struct","text":"<pre><code>set_struct(struct: str) -&gt; None\n</code></pre> <p>Set crystal structure type.</p> <p>Parameters:</p> Name Type Description Default <code>struct</code> <code>(FCC, BCC)</code> <p>Crystal structure type: <code>'FCC'</code>, <code>'BCC'</code>.</p> <code>'FCC'</code>"},{"location":"api/pypfc_ovito/#src.pypfc_ovito.setup.set_verbose","title":"set_verbose","text":"<pre><code>set_verbose(verbose: bool) -&gt; None\n</code></pre> <p>Set verbose output mode.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Provide verbose output, or not.</p> required"},{"location":"api/pypfc_pre/","title":"Class pypfc_pre","text":"<p>               Bases: <code>setup_base</code></p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre-functions","title":"Functions","text":""},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.__init__","title":"__init__","text":"<pre><code>__init__(\n    domain_size: Union[List[float], ndarray],\n    ndiv: Union[List[int], ndarray],\n    config: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>domain_size</code> <code>array_like of int, shape (3,)</code> <p>Number of grid divisions along each coordinate axis [nx, ny, nz].</p> required <code>ndiv</code> <code>array_like of int, shape (3,)</code> <p>Number of grid divisions along each coordinate axis [nx, ny, nz].</p> required <code>config</code> <code>dict</code> <p>Configuration parameters as key-value pairs. See the pyPFC overview for a complete list of the configuration parameters.</p> required"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.do_bicrystal","title":"do_bicrystal","text":"<pre><code>do_bicrystal(\n    xtal_rot: ndarray,\n    params: Optional[List[float]] = None,\n    liq_width: float = 0.0,\n    model: int = 0,\n) -&gt; np.ndarray\n</code></pre> <p>Define a bicrystal with two different crystal orientations.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>xtal_rot</code> <code>ndarray of float, shape (3,3,2)</code> <p>Crystal orientations (rotation matrices) for the two grains.</p> required <code>params</code> <code>list</code> <p>List containing parameters for the bicrystal model.</p> <ul> <li><code>model=0</code>: [r] - cylindrical crystal radius</li> <li><code>model=1</code>: [r] - spherical crystal radius</li> <li><code>model=2</code>: [gb_x1, gb_x2] - grain boundary positions along x</li> </ul> <code>None</code> <code>liq_width</code> <code>float</code> <p>Width of the liquid band along the grain boundary.</p> <code>0.0</code> <code>model</code> <code>int</code> <p>Density field layout.</p> <ul> <li>0: Cylindrical crystal, extending through z</li> <li>1: Spherical crystal  </li> <li>2: Bicrystal with two planar grain boundaries, normal to x</li> </ul> <code>0</code> <p>Returns:</p> Name Type Description <code>density</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value of <code>model</code> is not supported (should be 0, 1 or 2).</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.do_polycrystal","title":"do_polycrystal","text":"<pre><code>do_polycrystal(\n    xtal_rot: ndarray,\n    params: Optional[List[float]] = None,\n    liq_width: float = 0.0,\n    model: int = 0,\n) -&gt; np.ndarray\n</code></pre> <p>Define a polycrystal in a periodic 3D domain.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>xtal_rot</code> <code>ndarray of float, shape (3,3,n_xtal)</code> <p>Crystal orientations (rotation matrices) for n_xtal crystals.</p> required <code>params</code> <code>list</code> <p>List containing parameters for the polycrystal model.</p> <ul> <li><code>model=0</code>: No parameter needed. The number of crystal seeds is determined   from the number of provided orientations.</li> </ul> <code>None</code> <code>liq_width</code> <code>float</code> <p>Width of the liquid band along the grain boundaries.</p> <code>0.0</code> <code>model</code> <code>int</code> <p>Density field layout.</p> <ul> <li>0: A row of cylindrical seeds along y, with cylinders extending through z</li> </ul> <code>0</code> <p>Returns:</p> Name Type Description <code>density</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Polycrystal density field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value of <code>model</code> is not supported (should be 0).</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.do_single_crystal","title":"do_single_crystal","text":"<pre><code>do_single_crystal(\n    xtal_rot: Optional[ndarray] = None,\n    params: Optional[List[float]] = None,\n    model: int = 0,\n) -&gt; np.ndarray\n</code></pre> <p>Define a single crystal in a periodic 3D domain.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>xtal_rot</code> <code>ndarray of float, shape (3,3)</code> <p>Crystal orientation (rotation matrix). Default is an identity matrix.</p> <code>None</code> <code>params</code> <code>list</code> <p>List containing parameters for the single crystal model:</p> <ul> <li><code>model=0</code>: [r] - spherical crystal radius</li> <li><code>model=1</code>: [x1, x2] - crystal extent in x direction</li> <li><code>model=2</code>: [r] - cylindrical crystal radius</li> </ul> <code>None</code> <code>model</code> <code>(int, optional)</code> <p>Density field layout.</p> <ul> <li>0: Spherical crystal</li> <li>1: Crystal extending throughout y and z, covering interval in x</li> <li>2: Cylindrical crystal, extending through z</li> </ul> <code>0</code> <p>Returns:</p> Name Type Description <code>density</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value of <code>model</code> is not supported (should be 0 or 1).</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.evaluate_ampl_dens","title":"evaluate_ampl_dens","text":"<pre><code>evaluate_ampl_dens() -&gt; Tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Get density field amplitudes and phase densities for PFC simulations.</p> <p></p> <p>Returns:</p> Name Type Description <code>ampl</code> <code>ndarray of float, shape (npeaks,)</code> <p>Density field amplitudes for the specified crystal structure and  number of peaks.</p> <code>nLnS</code> <code>ndarray of float, shape (2,)</code> <p>Densities in the liquid (nL) and solid (nS) phases.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>npeaks</code> is not supported for the current crystal structure.</p> <code>ValueError</code> <p>If <code>sigma</code> value is not supported for the current configuration.</p> <code>ValueError</code> <p>If <code>struct</code> is not 'SC', 'BCC' or 'FCC' or if amplitudes and densities  are not available for the specified structure.</p> Notes <p>This method provides pre-calculated density field amplitudes and phase densities for different crystal structures (SC, BCC, FCC) and numbers of  Fourier peaks in the two-point correlation function. The values depend on the temperature-like parameter <code>sigma</code>.</p> <p>Fore efficiency, the method uses lookup tables of pre-computed values.</p> <p>Supported configurations:</p> <code>struct</code> <code>npeaks</code> <code>sigma</code> range SC 1 [0.0, 0.25] 2 [0.0, 0.22] 3 [0.0, 0.22] BCC 1 [0.0, 0.33] 2 [0.0, 0.30] 3 [0.0, 0.25] FCC 1 [0.0, 0.25] 2 [0.0, 0.25] 3 [0.0, 0.25]"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.generate_density_field","title":"generate_density_field","text":"<pre><code>generate_density_field(\n    crd: ndarray, g: ndarray\n) -&gt; np.ndarray\n</code></pre> <p>Define a 3D density field for (X)PFC modeling.</p> <p>Parameters:</p> Name Type Description Default <code>crd</code> <code>ndarray of float, shape (3,...)</code> <p>Grid point coordinates [x,y,z].</p> required <code>g</code> <code>ndarray of float, shape (3,3)</code> <p>Rotation matrix for crystal orientation.</p> required <p>Returns:</p> Name Type Description <code>density</code> <code>ndarray of float</code> <p>Density field for the specified crystal structure with appropriate Fourier modes and amplitudes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>struct</code> is not one of the supported crystal structures  ('SC', 'BCC', 'FCC', 'DC').</p> Notes <p>The density field is generated based on the current crystal structure  (<code>struct</code>) and density field amplitudes (<code>ampl</code>) settings.</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.get_ampl","title":"get_ampl","text":"<pre><code>get_ampl() -&gt; np.ndarray\n</code></pre> <p>Get the amplitudes in the density approximation.</p> <p>Returns:</p> Name Type Description <code>ampl</code> <code>ndarray of float, shape (N,)</code> <p>Amplitudes.</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.get_density","title":"get_density","text":"<pre><code>get_density() -&gt; np.ndarray\n</code></pre> <p>Get the density field.</p> <p>Returns:</p> Name Type Description <code>den</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field.</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.get_nlns","title":"get_nlns","text":"<pre><code>get_nlns() -&gt; np.ndarray\n</code></pre> <p>Get the liquid and solid phase densities.</p> <p>Returns:</p> Name Type Description <code>nlns</code> <code>ndarray of float, shape (2,)</code> <p>\\([n_{l},n_{s}]\\) where \\(n_{l}\\) is liquid phase density  and \\(n_{s}\\) is solid phase density.</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.get_npeaks","title":"get_npeaks","text":"<pre><code>get_npeaks() -&gt; int\n</code></pre> <p>Get the number of peaks in the density field approximation.</p> <p>Returns:</p> Name Type Description <code>npeaks</code> <code>int</code> <p>Number of peaks in the density field approximation.</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.get_sigma","title":"get_sigma","text":"<pre><code>get_sigma() -&gt; float\n</code></pre> <p>Get the temperature-like parameter sigma.</p> <p>Returns:</p> Name Type Description <code>sigma</code> <code>float</code> <p>Temperature-like parameter sigma</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.get_struct","title":"get_struct","text":"<pre><code>get_struct() -&gt; str\n</code></pre> <p>Get the crystal structure.</p> <p>Returns:</p> Name Type Description <code>struct</code> <code>str</code> <p>Crystal structure type: <code>'FCC'</code>, <code>'BCC'</code>.</p>"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.set_ampl","title":"set_ampl","text":"<pre><code>set_ampl(ampl: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the amplitudes in the density approximation.</p> <p>Parameters:</p> Name Type Description Default <code>ampl</code> <code>array_like of float, shape (N,)</code> <p>Amplitudes.</p> required"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.set_density","title":"set_density","text":"<pre><code>set_density(den: ndarray) -&gt; None\n</code></pre> <p>Set the density field.</p> <p>Parameters:</p> Name Type Description Default <code>den</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>Density field.</p> required"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.set_energy","title":"set_energy","text":"<pre><code>set_energy(ene: ndarray) -&gt; None\n</code></pre> <p>Set the PFC energy field.</p> <p>Parameters:</p> Name Type Description Default <code>ene</code> <code>ndarray of float, shape (nx,ny,nz)</code> <p>PFC energy field.</p> required"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.set_nlns","title":"set_nlns","text":"<pre><code>set_nlns(nlns: Union[List[float], ndarray]) -&gt; None\n</code></pre> <p>Set the liquid and solid phase densities.</p> <p>Parameters:</p> Name Type Description Default <code>nlns</code> <code>array_like of float, shape (2,)</code> <p>\\([n_{l},n_{s}]\\) where \\(n_{l}\\) is liquid phase density  and \\(n_{s}\\) is solid phase density.</p> required"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.set_npeaks","title":"set_npeaks","text":"<pre><code>set_npeaks(npeaks: int) -&gt; None\n</code></pre> <p>Set the number of peaks in the density field approximation.</p> <p>Parameters:</p> Name Type Description Default <code>npeaks</code> <code>int</code> <p>Number of peaks in the density field approximation.</p> required"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.set_sigma","title":"set_sigma","text":"<pre><code>set_sigma(sigma: float) -&gt; None\n</code></pre> <p>Set the temperature-like parameter sigma.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>float</code> <p>Temperature-like parameter sigma.</p> required"},{"location":"api/pypfc_pre/#src.pypfc_pre.setup_pre.set_struct","title":"set_struct","text":"<pre><code>set_struct(struct: str) -&gt; None\n</code></pre> <p>Set the crystal structure.</p> <p>Parameters:</p> Name Type Description Default <code>struct</code> <code>(FCC, BCC)</code> <p>Crystal structure type: <code>'FCC'</code>, <code>'BCC'</code>.</p> <code>'FCC'</code>"}]}